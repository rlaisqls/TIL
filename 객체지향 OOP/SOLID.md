
# SOLID
## 1. 단일 책임 원칙
### (Single Responsibility Principle, SRP)
 하나의 모듈는 하나의 책임만 가져야 한다. SRP를 적용하면 메소드의 책임 영역이 확실해지기 때문에 한 기능이 수정되었을 때 다른 연쇄작용을 일으키지 않는다. 또, 책임을 적절히 분배함으로써 코드의 가독성이 향상되고 유지보수가 용이해진다.

## 2. 개방 폐쇄 원칙
### (Open-Closed Principle, OCP) 
 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다. 코드를 수정하거나 기능을 추가할 일이 생겨도 기존 구성 요소는 바뀌지 말아야한다. 추상화와 다형성으로 구현할 수 있다. 

## 3. 리스코프 치환의 원칙
### (Liskov Substitutiong Principle, LSP)
 서브 타입은 기반 타입이 약속한 규약을 지켜야한다. 상속은 다형성을 통한 확장성 획득을 목표로 하기 때문에, 부모 객체를 자식 객체로 치환했을 때도 정상적으로 동작해야한다. LSP 원칙은 변화에 열려있는 프로그램을 만들 수 있도록 하는 바탕이다. OCP와도 연관된다.

## 4. 인터페이스 분리 원칙
### (Interface segregation Principle, ISP)
 한 클래스는 자신이 이용하지 않는 메서드에 의존하지 않아야힌다. 어떤 객체가 범위가 넓고 일반적인 인터페이스를 상속받으면 필요없는 메소드를 구현해야한다. 이것은 인터페이스에게 과하게 많은 책임을 지게 하는 일이다. ISP는 클라이언트로부터 발생하는 변경이 다른 클라이언트에 미치는 영향을 최소화하는 것을 목표로 한다.

## 5. 의존관계 역전 원칙
### (Dependency Icersion Principle, DIP)
 어떤 객체는 구체화에 의존하지 말고 추상화에 의존해야한다. 프로그램의 일부 기능이 수정될 때, 구체화에 의존하는 코드는 그 기능이 관여하는 부분을 모두 수정해야하지만 DIP를 지키면 같은 인터페이스를 상속받는 다른 클래스로 얼마든지 바꿔낄 수 있다. 의존성 주입을 적절히 사용하여 실현할 수 있다.

---

