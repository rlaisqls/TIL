## RAID(Redundant Array of Independent Disks)

직역하면 **복수 배열 저가/독립 디스크**이다. 저장장치 여러 개를 묶어 고용량, 고성능인 저장 장치 한 개와 같은 효과를 얻기 위해 개발된 기법이다.

RAID의 주 사용 목적은 크게 가용성과 고성능 구현으로 구분된다. 

동작 방식에 따라 Level 0~6으로 분류한다.

주로 사용되는 것은 0, 1, 5, 6이며 무정지 구현을 극도로 추구하면 RAID 1, 고성능 구현을 극도로 추구하면 RAID 0, RAID 5, 6은 둘 사이에서 적당히 타협한 형태이다.. RAID 10이나 RAID 01과 같이 두 가지 방식을 혼용하는 경우도 있다.

- RAID 0: 스트라이핑 기능(분배 기록) 사용
  - 여러 개의 멤버 하드디스크를 병렬로 배치하여 거대한 하나의 디스크처럼 사용한다. 데이터 입출력이 각 멤버 디스크에 공평하게 분배되며, 디스크의 수가 N개라면 입출력 속도 및 저장 공간은 이론상 N배가 된다. 다만 멤버 디스크 중 하나만 손상 또는 분실되어도 전체 데이터가 파손되며, 오류검출 기능이 없어 멤버 디스크를 늘릴수록 안정성이 떨어지는 문제가 있다.
   
- RAID 1: 미러링을 통해 두 개 이상의 디스크를 하나의 디스크처럼 사용
  - 각 멤버 디스크에 같은 데이터를 중복 기록한다. 멤버 디스크 중 하나만 살아남으면 데이터는 보존되며 복원도 1:1 복사로 매우 간단하기 때문에, 서버에서 끊김 없이 지속적으로 서비스를 제공하기 위해 사용한다.
  - 멤버 디스크를 늘리더라도 저장 공간은 증가하지 않으며, 대신 가용성이 크게 증가하게 된다. 상용 환경에서는 디스크를 2개를 초과해서 쓰는 경우가 드물지만, 극한 환경에서는 3개 이상의 멤버 디스크를 사용하기도 한다.
  
- RAID 2: ECC(에러 검출 기능) 탑재
  - 오류정정부호(ECC)를 기록하는 전용의 하드디스크를 이용해서 안정성을 확보한다. RAID 2는 비트 단위에 Hamming code를 적용한다.
  - 예를 들어, 디스크 1에 3, 디스크 2에 6을 저장하면 디스크 3에는 1+2의 값인 9를 저장한다. 이렇게 저장하면 디스크 1이 사라지더라도 디스크 2의 6의 값을 읽고, 디스크 3의 9의 값에서부터 디스크 1의 값 3을 읽을 수 있기 때문에 저장소 하나가 파손되더라도 데이터를 읽을 수 있는 것이다. 용량을 약간 희생하지만 하드가 고장났을때 데이터가 날아가는 일부 레이드 시스템에 비해 매우 높은 가용성과 저장용량 효율을 보인다.
  - 모든 I/O에서 ECC 계산이 필요하므로 입출력 병목 현상이 발생하며, ECC 기록용으로 쓰이는 디스크의 수명이 다른 디스크들에 비해 짧아지는 문제가 있어 현재는 사용하지 않는다. (RAID 3, RAID 4도 마찬가지이다.)

- RAID 3: 하나의 디스크를 에러검출을 위한 패리티 정보 저장용으로 사용하고 나머지 디스크에 데이터를 균등하게 분산 저장
  - 바이트 단위에 Hamming code를 적용한다.

- RAID 4: RAID 3 방식과 같지만 블록 단위로 분산 저장
  - 블록 단위에 Hamming code를 적용한다.

- RAID 5: 하나의 디스크에 패리티 정보를 저장하지 않고 분산 저장 (회전식 패리티 어레이)
  - 패리티를 한 디스크에 밀어 넣지 않고 **각 멤버 디스크에 돌아가면서 순환적으로 저장**하여 입출력 병목 현상을 해결한다. N개의 디스크를 사용하면 (N-1)배의 저장 공간을 사용할 수 있다. RAID 4처럼 하나의 멤버 디스크 고장에는 견딜 수 있지만 디스크가 두 개 이상 고장 나면 데이터가 모두 손실된다. 데이터베이스 서버 등 큰 용량과 무정지 복구 기능을 동시에 필요로 하는 환경에서 주로 쓰인다.
  - 매번 쓰기 작업 때마다 패리티 연산 과정이 추가되어, 성능을 보장하려면 고가의 패리티 연산 전용 프로세서와 메모리를 사용해야 한다. 멤버 디스크도 최소 3개 이상 사용해야 하므로 초기 구축 비용이 비싸다는 단점이 있다. 

- RAID 6: 하나의 패리티 정보를 두개의 디스크에 분산 저장. 쓰기 능력은 저하될 수 있지만 고장 대비 능력이 매우 높음. 두 개의 오류까지 검출 가능.
  - RAID 5와 원리는 같으며, 서로 다른 방식의 패리티 2개를 동시에 사용한다. 성능과 용량을 희생해서 가용성을 높인 셈. N개의 디스크를 사용하면 (N-2)개의 저장 공간을 사용할 수 있다. RAID 5가 1개까지의 고장을 허용하는 것에 반해 이쪽은 2개까지 허용한다.
  - 스토리지 서버와 같이 디스크를 빼곡히 꽂는(기본 10개 단위) 환경에서 RAID 5는 유지보수가 어려우며, 어레이 안정성을 높이기 위한 목적으로 주로 사용된다.
  - Disk fail이 2개 동시에 나지 않는다면 정보를 보호할 수 있다.
  - 컨트롤러가 RAID 5보다 더 비싸고, 멤버 디스크도 기본 4개 이상 확보해야 하므로 초기 구축 비용이 비싸다.
  - 하드디스크 가용성이 RAID 5보다 높아야 하는 상황에서 쓰인다.

## Nested RAID

레이드 볼륨의 멤버로 다른 레이드 볼륨을 사용하는 형태이다. 볼륨 확장 과정에서 구성 편의성 문제로 형성되는 경우가 많다. 이 때 멤버 디스크를 묶는 배열을 하위 배열, 하위 배열을 묶는 배열을 상위 배열이라고 한다. 표기 방법은 (하위 배열 숫자)(상위 배열 숫자) 형식이다. 만약 하위 배열 숫자가 0이면 혼동을 피하기 위해 +상위배열 숫자를 적는다. 대표적인 예시로 10, 0+1, 15, 50, 0+5, 51 등이 존재한다.

- RAID 10
  - 하위 배열은 RAID 1, 상위 배열은 RAID 0이다. RAID 1로 미러링 된 볼륨을 RAID 0으로 스트라이핑 한다.
  - 퍼포먼스 및 용량 위주로 구성한다면, 디스크 2개를 RAID 1로 묶은 미러 볼륨 3개를 RAID 0으로 스트라이핑 한다. 이 경우 사용 가능한 총 용량은 3TB가 된다.
  - 가용성 위주로 구성한다면, 디스크 3개를 RAID 1로 묶은 미러 볼륨 2개를 RAID 0으로 스트라이핑 한다. 이 경우 사용 가능한 총 용량은 2TB가 된다.
  - RAID 0+1에 비해 디스크 장애 발생 시 복구가 수월하다.
  
- RAID 0+1: 최소 4개 이상의 디스크를 2개씩 스트라이핑으로 묶고(RAID 0) 미러링으로 결합(RAID 1)한 방식 - RAID 10: 두 개의 디스크를 미러링으로 묶고(RAID 1) 스트라이핑(RAID 0)으로 결합한 방식
  - 하위 배열은 RAID 0, 상위 배열은 RAID 1이다. RAID 0으로 스트라이핑 된 볼륨을 RAID 1로 미러링 한다.
  - 퍼포먼스 및 용량 위주로 구성한다면 디스크 3개를 RAID 0으로 묶은 스트라이프 볼륨 2개를 RAID 1로 미러링 한다. 이 경우 사용 가능한 총 용량은 3TB가 된다.
  - 가용성 위주로 구성한다면, 디스크 2개를 RAID 0으로 묶은 스트라이프 볼륨 3개를 RAID 1로 미러링 한다. 이 경우 사용 가능한 총 용량은 2TB가 된다.
  - RAID 10에 비해 RAID 볼륨이 깨졌을 경우 복구가 번거롭다. RAID 10과 비교하자면, 미러 볼륨으로 구성된 어레이에서 디스크 하나가 고장이 났다면, 미러 볼륨 자체는 깨지지 않는다. 즉, 디스크만 바꿔 넣어주면 알아서 리빌딩하여 원래 상태로 돌아간다. 하지만 RAID 0+1의 경우 디스크 하나가 고장이 났다면, 해당 RAID 0 어레이 전체가 깨져 버린다. 디스크를 교체한 뒤 RAID 0 어레이를 다시 구성한 다음, 미러링해야 한다.

생성된 RAID 장치에 대한 레벨 정보를 확인할 때 사용하는 파일 -> `/proc/mdstat`

---
참고
- https://en.wikipedia.org/wiki/RAID
- http://bitsavers.trailing-edge.com/pdf/ibm/7030/22-6530-2_7030RefMan.pdf#page=160