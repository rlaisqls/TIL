
## AES (Advanced Encryption Standard)

- 현재 가장 널리 사용되는 대칭 암호화 표준이다.
- NIST에서 2001년 표준으로 채택되었으며, 이전 암호화 표준이었던 DES를 대체했다.

- 128비트의 평문을 128비트의 암호문으로 암호화한다.
  - 고정된 크기의 평문을 암호화하기 때문에 블록 암호(Block cipher)

- 내부 동작
  - AES는 암호화 과정에서 평문의 state를 4*4 행렬로 본다.
  - 여러 번 반복하는 라운드 함수에서, 라운드별로 (기본 대칭키에서 파생된) 각각 다른 라운드 키를 사용한다.
    - 이를 통해 대칭 키의 비트를 약간만 변경함녀 완전히 다른 암호화가 가능하다 (확산 diffusion)
  - 각 라운드엔 4개의 내부 단계가 있다.
    - SubBytes: S-box를 사용하여 각 바이트를 비선형 치환한다.
    - ShiftRows: 각 행을 왼쪽으로 순환 이동시킨다.
    - MixColumns: 각 열에 선형 변환을 적용하여 바이트들을 섞는다.
    - AddRoundKey: 라운드 키와 state를 XOR 연산한다.

- AES는 블록 자체만 암호화할 수 있기 때문에, 정확히 128 비트가 아닌 것을 암호화하려면 패딩, 작동 모드를 사용해야한다.
  - 패딩 바이트를 선택하는 방법에는 여러가지가 있다.
    - PKCS#7: 8바이트를 패딩하는 경우 08로 나머지 바이트를 채움
    - PKCS#1, OAEP 등등이 있음

- 작동 모드
  - ECB(Cipher Block Chaining)
    - 단순하게 16바이트 블록으로 나누어 암호화하는 방법
    - ECB 펭귄처럼, 암호화한 결과에서 기존 데이터의 패턴이 그대로 드러날 수 있다.
  - CBC(Cipher Block Chaining)
    - Initialization Vector로 암호화를 부작위한다.
    - IV를 평문의 첫 바이트와 XOR하고, 암호화할 평문이 더 있다면 이전 암호문을 사용하여 다음 블록과 XOR한 후 암호화한다.
    - IV는 고유한 무작위 값으로 설정해야한다. 그렇지 않으면 BEAST(Browser Exploit Against SSL/TLS) 공격과 같은 영리한 공격이 가능해진다.
  - AES-CBC-HMAC
    - CBC에서 공격자는 암호문과 IV를 수정할 수 있다. 예를 들어 CBC에서 공격자는 IV 및 암호문의 비트를 뒤집음으로써 평문의 특정 비트를 뒤집을 수 있다.
    - IV와 암호문에 MAC을 적용한 인증태그를 함께 확인하는 방법을 사용할 수 있다.
    - (암호문에 MAC을 같이 사용하는 구조를 Encrypt-then-MAC이라 한다. MAC-then-Encrypt는 Vaudenay padding oracle 공격 등으로 이어질 수 있으므로 피해야한다.)

- AEAD(Authenticated Encryption with Associated Data)
  - 연관 데이터 인증 구조화, 동일한 연관 데이터 및 IV를 사용해야 복호화 가능
  - AES-CTR(AES with Counter)
    - 평문 대신 논스를 암호화하고, 그 결과에 평문을 XOR한다.
    - 여러 버전의 TLS 프로토콜을 포함하여 암호학 프로토콜에 사용되는 주요 암호이다.

  - AES-GCM(AES with Galois/Counter Mode)
    - CTR 모드 암호화와 GHASH 인증을 결합한 AEAD 모드이다.
    - 동작 방식
      - 암호화: 128비트 카운터를 AES(키 K)로 암호화하고, 결과를 평문과 XOR하여 암호문을 생성한다. 블록별로 병렬 처리가 가능하다.
      - 인증: 추가 인증 데이터(AAD)와 암호문 블록들을 키 종속 상수 H와 갈루아 필드 GF(2^128)에서 곱셈 연산하여 인증 태그를 생성한다.
      - 인증 키 H는 마스터 키로부터 유도된다: `H = AES(Key, 0)`

      ```
      ┌─────────────────────────────────────────────────────┐
      │ 암호화 (CTR 모드)                                   │
      │ Nonce + Counter ──> AES(Key) ──> XOR ──> Ciphertext │
      │                                   ▲                 │
      │                               Plaintext             │
      └─────────────────────────────────────────────────────┘
      ┌─────────────────────────────────────────────────────┐
      │ 인증 (GHASH)                                        │
      │ AAD (추가 인증 데이터) ┐                            │
      │                        ├──> GHASH(H) ──> Auth Tag   │
      │        Ciphertext ─────┘     (GF(2^128) 곱셈)       │
      │                                                     │
      │ H = AES(Key, 0)  (키로부터 유도)                    │
      └─────────────────────────────────────────────────────┘
      출력: Ciphertext + Auth Tag
      ```

  - ChaCha20-Poly1305(ChaCha20 with Poly1305)
    - ChaCha20 암호화와 Poly1305 MAC을 결합한 AEAD 모드이다. 하드웨어 지원을 사용할 수 없을 때 느린 AES와 달리 소프트웨어에서 사용할 때 빠른 속도를 위해 설계되었다.
    - AES-GCM과 유사항 구조이지만 ChaCha20은 스트림 암호이고 소프트웨어 구현에 최적화되었다는 것이 차이점이다.
    - 동작 방식
      - 암호화: ChaCha20 스트림 암호로 키스트림을 생성하고 평문과 XOR하여 암호문을 생성한다.
      - 인증: Poly1305 MAC으로 AAD와 암호문의 인증 태그를 생성한다.
      - Poly1305 키는 ChaCha20으로 생성된다: 첫 번째 블록 `ChaCha20(Key, Nonce, counter=0)`을 Poly1305 키로 사용
    - TLS 1.3, WireGuard VPN 등에서 사용된다.

---
참고

- 리얼월드 암호학 - 데이비드 웡
- <https://www.rfc-editor.org/rfc/rfc5288>
- <https://en.wikipedia.org/wiki/Galois/Counter_Mode>
- <https://en.wikipedia.org/wiki/Symmetric-key_algorithm>
- <https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf>
