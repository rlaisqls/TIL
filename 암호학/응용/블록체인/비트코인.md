### 직렬화

**SEC(Standards for Efficient Cryptography)**

- ECDSA 공개키를 직렬화하는 표준
- 비압축식
  - 65바이트
  - 표현
    1. 0x04의 1바이트 접두부로 시작
    2. x 좌표를 32바이트 빅엔디언 정수로 표현
    3. y 좌표를 32바이트 빅엔디언 정수로 표현
- 압축식
  - 33바이트
  - 아래 원리로, y가 짝수인지 여부만 기록하는 방식
    - `-y % p = (p-y) % p`이기에, (x, y)가 방정식을 만족시키면 (x, p-y) 도 방정식을 만족시킴
    - p는 2보다 큰 소수이기에 p는 홀수임
    - y는 정수이므로, y와 p-y 중 하나는 짝수이고 하나는 홀수
  - 표현
    1. y값이 짝수면 0x02, 홀수면 0x03 접두부로 시작
    2. x 좌표를 32바이트 빅엔디언 정수로 표현
  - x로부터 y 계산하는 법
    - 알려진 v에 대해 w² = v를 만족하는 w를 구해야함.
    - 페르마의 소정리 wᵖ⁻¹ % p = 1로부터 다음처럼 전개할 수 있다.
      - w² = w²⋅1 = w²⋅wᵖ⁻¹ = w⁽ᵖ⁺¹⁾
      - w = w⁽ᵖ⁺¹⁾/² = w²⁽ᵖ⁺¹⁾/⁴ = (w²)⁽ᵖ⁺¹⁾/⁴ = v⁽ᵖ⁺¹⁾/⁴
      - secp256k1에서 사용하는 p는 p%4=3인 성질을 만족하기 때문에 (p+1)%4=0이 됨, 즉 (p+1)/4는 정수
    - 따라서 유한체 w² = v를 만족하는 w 값은 v⁽ᵖ⁺¹⁾/⁴

**DER(Distinguished Encoding Rules)**

- 최대 72바이트
- <https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf>
- signature도 직렬화해야함. r로부터 s를 유도할 수 없기에 SER처럼 압축할 수 없음
- 표현
  1. 0x30 바이트로 시작
  2. 서명의 길이를 붙임 (보통 `0x44`~`0x45`, 10진수로 `68`~`67`)
  3. r 값을 시작하는 표식으로 0x02을 붙임
  4. 빅엔디언 정수로 r 값 표현.
      - 그 결과의 첫 번째 바이트가 0x80보다 크거나 같으면 00을 앞에 붙임. 이후, 바이트 단위의 길이를 다시 앞에 붙임.
      - 부호 있는 이진수에서 첫 번째 비트가 1인 경우(=0x80보다 크면) 음수를 의미하기 때문
  5. s 값을 시작하는 표식으로 0x02을 붙임
  6. 빅엔디언 정수로 s 값 표현.
      - 그 결과의 첫 번째 바이트가 0x80보다 크거나 같으면 00을 앞에 붙임. 이후, 바이트 단위의 길이를 다시 앞에 붙임.

### 비트코인 주소 및 WIF 형식

- 주소 표현을 위해 오랫동안 Base58을 사용하고 있으나, BIP0173에서 Bech32 표준이 제안되어 일부(Segwit)에서 사용되기 시작하는 추세
- 비트코인 주소 생성 방법
  1. 메인넷 주소는 0x00, 테스트넷 주소는 0x6f로 시작
  2. 압축 혹은 비압축 SEC 형식 주소를 sha256 해시함수에 넣고, 다시 ripemd160 해시 함수에 넣어 출력을 얻음.
      - 이렇게 연속으로 2개의 해시함수는 적용하는 방법을 [hash160](https://www.btcschools.net/bitcoin/bitcoin_tool_hash160.php)이라 함
  3. 1의 접두 바이트와 2의 최종 해시 결과를 합침
  4. 3의 결과와 체크섬(3에서 얻은 결과를 hash256로 해시하고 그 결과에서 첫 4바이트를 취함)을 합친 후 Base58로 부호화

- 비트코인에서 비밀키는 256 비트 숫자, 보통 전파하지 않지만 드물게 종이 지갑에서 소프트웨어 지갑으로 전송하는 경우 WIF 형식 사용
  1. 메인넷 비밀키는 0x80, 테스트넷 주소는 0xef로 시작
  2. 비밀키를 32바이트 길이의 빅 엔디언으로 표현
  3. 공개키를 압축 SEC 형식으로 표현했다는 표식으로 0x01를 붙임
  4. 1번을 순서대로 연결
  5. 4의 결과와 체크섬(4에서 얻은 결과를 hash256로 해시하고 그 결과에서 첫 4바이트를 취함)을 합친 후 Base58로 부호화

### 트랜잭션

- 트랜잭션은 암호화되지 않으며 공개적으로 조회할 수 있다.
- 각 트랜잭션은 이중 SHA-256 해시를 통해 생성된 고유한 트랜잭션 ID(TXID)를 가짐
- 이전 트랜잭션의 출력(UTXO, Unspent Transaction Output)을 입력으로 참조하는 UTXO 모델을 사용한다.

트랜잭션 구성 요소

1. Version: 트랜잭션 형식의 버전 번호
2. Inputs: 4개의 하부 필드를 가지고 있음
    - Previous Tx ID
    - Previous Tx index (출력 번호)
    - ScriptSig (해제 스크립트, [varInt](https://wiki.bitcoinsv.io/index.php/VarInt) 형식)
    - Sequence
3. Outputs: 2개의 하부 필드를 가지고 있음
    - 비트코인 금액
    - ScriptPubKey (잠금 스크립트)
4. Locktime: 트랜잭션의 유효 시점을 규정

Inputs

- 하나의 입력은 1개부터 2³² 개의 이전 트랜잭션 출력을 참조할 수 있으며, 모든 입력값은 완전히 할당되어야 하고, 할당되지 않은 사토시는 채굴 수수료로 지불된다.

- 시퀀스 필드는 매우 빈번한 거래를 록타임 필드와 함께 표현하기 위함이었으나, 채굴자들이 악용할 수 있는 구조적 문제로 인해 원래 의도대로 사용되지 못했다.

  - 원래 의도는 같은 입력을 사용하는 여러 버전의 트랜잭션 중 가장 높은 시퀀스 번호를 가진 최신 버전을 채택하는 것이었다.
  - e.g. alice와 bob이 지불 채널을 운영
    - 처음에 alice가 밥에게 1 BTC를 지불하는 트랜잭션(시퀀스 1)을 생성하고
    - 나중에 합의를 변경하여 0.5 BTC만 지불하는 트랜잭션(시퀀스 2)을 생성하는 경우
    - 가장 높은 시퀀스 번호인 2번 트랜잭션이 최종적으로 블록에 포함되어야 한다.

  - 하지만 채굴자는 mempool에 있는 여러 버전의 트랜잭션 중 자신에게 유리한 것을 선택할 수 있는 권한이 있기 때문에, 밥으로부터 뇌물을 받거나 더 높은 수수료를 제공받아 시퀀스 1 트랜잭션(1 BTC 지불)을 의도적으로 채택할 수 있다.
  - 이런 경우 앨리스는 최신 합의인 0.5 BTC가 아닌 1 BTC를 잃게 되므로, 채굴자의 선택에 따라 거래 당사자의 의도와 다른 결과가 발생할 수 있다.

- 따라서 현재는 시퀀스 대신 RBF(Replace-By-Fee)와 `OP_CHECKSEQUENCEVERIFY`로 주로 사용되고 있다.

  - 아주 작은 수수료로 트랜잭션을 보낸 경우 채굴자들은 수수료가 작기 때문에 이 트랜잭션을 블록에 포함시키는 것을 주저할 수 있음. 이 경우 보낸 트랜잭션은 mempool이라고 하는 채굴 컴퓨터의 메모리에 계속해서 머무르게 됨.
  - 본인의 트랜잭션을 빨리 블록에 포함시키고 싶을 때, 같은 입력에서 출력 수수료를 올려 다시 보내는 것을 RBF라 함.
  - 단 대체되는 트랜잭션의 시퀀스 필드는 `0xfeffffff`로 설정되어있어야 한다.

Outputs

- 비트코인 단위는 64bit 사토시 단위로 표현한다. (1 BTC = 100,000,000 satoshi)

- UTXO(Unspent transaction output)은 아직 사용하지 않은 트랜잭션 출력으로, 네트워크상의 풀 노드들은 UTXO 집합을 항상 최신 상태로 유지해야한다.
  - UTXO 집합에서 이전 트랜잭션 출력을 확인해보는 것으로 손쉡게 이중 지불을 막을 수 있다.
  - 만약 새 트랜색션의 입력이 UTXO 집합에 없는 이전 트랜잭션의 출력을 가리킨다면 전파하지 않고 버릴 수 있다.
  - 트랜잭션을 검증하기 위해 이전 트랜잭션 출력으로부터 금액과 잠금 스크립트를 자주 확인해야하기 때문에, 집합 내 UTXO 내용을 빠르게 확인할 수 있으면 검증도 빨라진다.

- 채굴자가 트랜잭션을 블록에 포함시킬 동기가 되는 수수료는, 단순이 입력의 합에서 출력의 합을 뺀 값이다.
  - 입력은 금액 필드를 갖고 있지 않기 때문에 이전 트랜잭션의 출력에서 찾아야한다. 만양 풀 노드를 갖고 있지 않다면 믿을 수 있는 제 3자가 제공하는 풀 노드로부터 이 정보를 얻어야한다.

Locktime

- 트랜잭션 전파 후 실행을 지연시키는 방법을 제공한다. (e.g. 600,00의 록타임을 가지는 트랜잭션은 600,001 블록까지는 블록체인에 포함될 수 없다.)
- 록타임 값이 500,000,000보다 작으면 블록 높이로, 같거나 크면 유닉스 타임으로 해석한다.
- 입력에 포함된 시퀀스 값이 `ffffffff`면 록타임은 무시된다.
- 록타임의 주요 문제는 록타임에 도달했을 때 트랜잭션의 수신자가 트랜잭션이 유효한지 확신할 수 없다는 점이다. 시가닝 많이 지나 부도 가능성이 있는 은행 수표와 비슷하다.
  - BIP65에서 도입한 `OP_CHECKSEQUENCEVERIFY`는 록타임까지 출력을 사용하지 못하게 해서 이러한 상황을 방지한다.

### 스크립트

- 스크립트는 프로그래밍 언어이다. 연산자와 데이터를 가지고, 스택 기반으로 주어진 명령어가 하나씩 처리된다.
- ScriptPubKey와 ScriptSig 모두 같은 방식으로 파싱된다.
- 파싱을 시작하고 처음 읽은 한 바이트 값이 n이고 이 값이 `0x01`~`0x4b`(1~75) 사이의 값이면 n바이트 길이만큼 이어서 읽은 숫자를 한 원소로 간주한다. 그렇지 않으면 그 바이트 값은 오피 코드를 의미한다. [연산자, 오피코드 대응 표](https://en.bitcoin.it/wiki/Script)
  
- 비트코인의 스크립트에선 반복문을 허용하지 않는다. (튜링 완전하지 않다.)
  - 튜링 완전한 스마트 계약 언어인 Solidity를 이용하는 이더리움은 gas라고 하는 무언가를 프로그램 실행 대가로 지불하도록 강제하여 해결한다.

- 거래를 하기 위해선 이전 트랜잭션의 해제 스크립트(ScriptPubKey)로 코인을 해제 후, 이번 트랜잭션의 잠금 스크립트(ScriptSig)로 잠가야 한다. 따라서 이전 트랜잭션 정보를 가져와야한다.

- 비트코인에서 해제 스크립트는 잠금 스크립트와 분리되어 실행된다. 이는 해제 스크립트가 잠금 스크립트 실행에 영향을 주지 않도록 하기 위해서이다. 결합하여 실행하는 경우, 해제 스크립트에서 잠금하지 않고 return 1하여 종료되는 허점이 생긴다.

스크립트 예시

- P2PK(Pay to Public Key)
  - 비트코인 초기에 널리 사용됨
  - ECDSA 서명 공개키로 보내고, 비밀키 소유자는 서명을 통해 비트코인을 해제하고 사용할 수 있음.
  - 스크립트
    - ScriptPubKey: `<signature>`
      - ac는 `OP_CEHECKSIG`를 의미함
    - ScriptSig: `<pubkey>ac`
  - 해제/잠금 스크립트를 합쳐 실행하면 `<signature><pubkey>ac`, `OP_CEHECKSIG`가 앞의 2개 원소를 꺼내어 공개키로 서명이 올바른지 확인한다.
  - `OP_CEHECKSIG` 연산자는 서명이 올바르면 스택 위에 1을, 아니면 0을 올린다.
  - 초기 IP to IP 지불이나 채굴 비트코인이 있는 출력에 사용되었다. 하지만 IP to IP 지불 시스템은 MITM 공격에 취약해 점차 사용하지 않게 되었다.
  - 사람간의 거래에선 공개키의 길이가 길어 불편하고, UTXO 집합의 크기를 많이 차지한다는 단점이 있다.

- P2PKH(Pay to Public Key Hash)
  - P2PK 스크립트 대비 짧은 주소를 사용하고, hash160으로 추가 보호한다는 장점이 있다.
  - SEC 형식 공개키가 잠금 스크립트가 아닌 해제 스크립트에 있다는 차이가 있다.
    - P2PK는 ScriptPubKey에 공개키가 직접 노출되어 블록체인에 영구적으로 기록되지만, P2PKH는 코인을 사용하는 시점(ScriptSig)까지 공개키가 드러나지 않는다.
    - 양자 컴퓨터의 Shor's algorithm은 공개키로부터 개인키를 계산할 수 있는데, P2PKH에서는 사용하지 않은 UTXO의 경우 공개키가 노출되지 않아 양자 컴퓨터 공격에 대한 시간적 여유를 확보할 수 있다.
    - 공격자가 개인키를 얻으려면 먼저 hash160(SHA256 + RIPEMD160)을 역산하여 공개키를 찾고, 그 다음 ECDSA를 깨서 개인키를 찾아야 하는 이중 보호층이 있다.

  - 스크립트
    - ScriptPubKey

       ```
       P_PUSHBYTES_72
       <signature>
       OP_PUSHBYTES_33
       <publickey> 
       ```

    - ScriptSig

       ```
       OP_DUP
       OP_HASH160
       OP_PUSHBYTES_20
       <publickey hash>
       OP_EQUALVERIFY
       OP_CHECKSIG
       ```

- P2RPH(Pay to R-Puzzle Hash)
  - R-Puzzle은 k 값에 대한 지식 증명을 사용하여 코인을 사용할 수 있도록 하는 스크립트이다.
  - k는 비트코인 개인키와 동일한 수학적 집합에서 가져온 값이며, r(k와 생성자 점을 곱한 x 좌표)을 생성하는데 사용된다.
  - 스크립트
    - ScriptSig

      ```
      <sig'> <sig> <pubKey>
      ```

    - ScriptPubKey

      ```
      OP_OVER
      OP_3
      OP_SPLIT
      OP_NIP
      OP_1
      OP_SPLIT
      OP_SWAP
      OP_SPLIT
      OP_DROP
      OP_HASH160
      <rHash>
      OP_EQUALVERIFY
      OP_TUCK
      OP_CHECKSIGVERIFY
      OP_CHECKSIG
      ```

  - 공개키가 스크립트 솔루션의 일부로 검증되지 않기 때문에, 임의의 키 쌍을 사용하여 트랜잭션에 서명할 수 있다.

- P2MS(Pay to Multi-Signature)
  - 여러 공개키로 비트코인을 잠그고, 그 중 일부(또는 전부)의 서명을 요구하여 잠금을 해제하는 스크립트이다.
  - m-of-n 표기법을 사용한다. (예: 2-of-3는 3개의 공개키 중 2개의 서명이 필요함)
  - 스크립트 (2-of-3 multisig 예시)
    - ScriptSig

      ```
      OP_0
      <signature1>
      <signature2>
      ```

      - OP_CHECKMULTISIG의 off-by-one 버그로 인해 더미 값(OP_0)이 필요하다.

    - ScriptPubKey

      ```
      OP_2
      <pubkey1>
      <pubkey2>
      <pubkey3>
      OP_3
      OP_CHECKMULTISIG
      ```

  - 블록체인에서 P2MS를 직접 사용하는 것은 드물며, 대부분 P2SH나 P2WSH로 래핑되어 사용된다.
  - 노드 중계를 위해 최대 3개의 공개키로 제한된다.

- 인증키 등을 이용한 표준 스크립트 뿐만 아니라, 덧셈 문제를 푸는 등의 잠금/해제 스크립트를 작성하는 것도 가능하다.
  - 일례로 Peter Todd가 해시 충돌을 찾은 사람이 가져갈 수 있도록 잠근 비트코인이 있다.
  - 구글이 2017년 2월 SHA-1에 대한 해시 충돌을 찾았고, 이외 SHA에 대한 해시 충돌을 찾으면 해제할 수 있는 비트코인도 있다.
  - 참고
    - <https://bitcointalk.org/index.php?topic=293382>
    - <https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html>

### 트랜잭션 검증과 생성

트랜잭션을 수신한 후 모든 노드는 트랜잭션이 네트워크 규칙에 부합되도록 만들어졌는지 확인한다. 아래와 같은 항목을 주로 확인한다.

1. 트랜잭션의 입력이 가리키는 비트코인이 존재하고 사용 가능한가? (이중 지불 방지)

    - 모든 풀 노드는 자신이 관리하고 있는 UTXO 집합을 들여다보는 것으로 비트코인이 존재하고 사용 가능한지 확인할 수 있다. 단순히 트랜잭션 하나를 보는 것으론 알 수 없다.
    - 풀 노드는 이중 지불 여부를 쉽게 확인할 수 있지만 라이트 노드는 이런 정보를 외부에서 가져와야한다.

2. 입력 비트코인의 합이 출력 비트코인의 합보다 크거나 같은가? (코인이 생성되지 않도록 함)

    - 코인을 생성할 수 있는 것은 코인 베이스 트랜잭션 뿐이다. 이외 트랜잭션에선 코인이 생성되면 안된다.
    - 위에서도 언급했듯, 입력에는 명시적인 비트코인 금액 정보가 없으므로 UTXO 집합에서 찾아야한다. 라이트 노드는 풀 노드에게 이 정보를 물어야한다.

3. 입력 해제 스크립트는 참조하는 출력의 잠금 스크립트를 해제하는가?

    - e.g. ECDSA 서명 검증 과정
      1. 서명 (r, s), 공개키 P, 메시지 해시 z를 준비한다.
         - z는 트랜잭션 데이터를 이중 SHA-256 해시하여 생성한다.
         - r과 s는 DER 형식으로 직렬화된 서명에서 파싱한다.
         - P는 SEC 형식으로 직렬화된 공개키를 파싱한다.
      2. u = z/s mod n을 계산한다. (n은 secp256k1 곡선의 위수)
      3. v = r/s mod n을 계산한다.
      4. R' = uG + vP를 계산한다. (G는 생성자점, P는 공개키)
         - 타원곡선 점 덧셈 연산을 수행하여 새로운 점 R'을 얻는다.
      5. r == R'.x mod n인지 확인한다.
         - R'의 x 좌표와 서명의 r 값이 일치하면 서명이 유효하다.
         - 일치하면 스택에 1을 푸시하고, 일치하지 않으면 0을 푸시한다.
    - 이 과정을 통해 서명자가 개인키를 소유하고 있음을 증명하면서도, 개인키 자체는 노출하지 않는다.

- <https://teachbitcoin.io/presentations/transaction_sighash.html>
- <https://developer.bitcoin.org/devguide/transactions.html>

---

관련 테스트 및 탐방 사이트

- <https://cryptolinks.com/>
- testnet faucet에서 테스트넷용 코인을 무료로 얻을 수 있음 (e.g. <https://faucet-list.com/testnet-faucets/bitcoin>)
- 현재 동작중인 풀 노드의 IP 주소와 port 번호 검색: <https://bitnodes.io/nodes/>
- 블록 탐색기
  - <https://blockstream.info/testnet/>
  - <https://live.blockcypher.com/btc-testnet/>

---

참고

- 밑부터 시작하는 비트코인 (Programming Bitcoin by Jimmi Song, O'Reilly)
- <https://wiki.bitcoinsv.io/index.php/Bitcoin_Transactions>
- <https://wiki.bitcoinsv.io/index.php/VarInt>
- <https://www.btcschools.net/bitcoin/bitcoin_tool_hash160.php>
- <https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf>
- 스크립트
  - <https://learnmeabitcoin.com/technical/script/>
  - <https://learnmeabitcoin.com/technical/script/p2pkh/>
