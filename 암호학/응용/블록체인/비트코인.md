### 직렬화

SEC(Standards for Efficient Cryptography)

- ECDSA 공개키를 직렬화하는 표준
- 비압축식
  - 65바이트
  - 표현
    1. 0x04의 1바이트 접두부로 시작
    2. x 좌표를 32바이트 빅엔디언 정수로 표현
    3. y 좌표를 32바이트 빅엔디언 정수로 표현
- 압축식
  - 33바이트
  - 아래 원리로, y가 짝수인지 여부만 기록하는 방식
    - `-y % p = (p-y) % p`이기에, (x, y)가 방정식을 만족시키면 (x, p-y) 도 방정식을 만족시킴
    - p는 2보다 큰 소수이기에 p는 홀수임
    - y는 정수이므로, y와 p-y 중 하나는 짝수이고 하나는 홀수
  - 표현
    1. y값이 짝수면 0x02, 홀수면 0x03 접두부로 시작
    2. x 좌표를 32바이트 빅엔디언 정수로 표현
  - x로부터 y 계산하는 법
    - 알려진 v에 대해 w² = v를 만족하는 w를 구해야함.
    - 페르마의 소정리 wᵖ⁻¹ % p = 1로부터 다음처럼 전개할 수 있다.
      - w² = w²⋅1 = w²⋅wᵖ⁻¹ = w⁽ᵖ⁺¹⁾
      - w = w⁽ᵖ⁺¹⁾/² = w²⁽ᵖ⁺¹⁾/⁴ = (w²)⁽ᵖ⁺¹⁾/⁴ = v⁽ᵖ⁺¹⁾/⁴
      - secp256k1에서 사용하는 p는 p%4=3인 성질을 만족하기 때문에 (p+1)%4=0이 됨, 즉 (p+1)/4는 정수
    - 따라서 유한체 w² = v를 만족하는 w 값은 v⁽ᵖ⁺¹⁾/⁴

DER(Distinguished Encoding Rules)

- 최대 72바이트
- <https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf>
- signature도 직렬화해야함. r로부터 s를 유도할 수 없기에 SER처럼 압축할 수 없음
- 표현
  1. 0x30 바이트로 시작
  2. 서명의 길이를 붙임 (보통 `0x44`~`0x45`, 10진수로 `68`~`67`)
  3. r 값을 시작하는 표식으로 0x02을 붙임
  4. 빅엔디언 정수로 r 값 표현.
      - 그 결과의 첫 번째 바이트가 0x80보다 크거나 같으면 00을 앞에 붙임. 이후, 바이트 단위의 길이를 다시 앞에 붙임.
      - 부호 있는 이진수에서 첫 번째 비트가 1인 경우(=0x80보다 크면) 음수를 의미하기 때문
  5. s 값을 시작하는 표식으로 0x02을 붙임
  6. 빅엔디언 정수로 s 값 표현.
      - 그 결과의 첫 번째 바이트가 `0x80`보다 크거나 같으면 00을 앞에 붙임. 이후, 바이트 단위의 길이를 다시 앞에 붙임.

### 비트코인 주소 및 WIF 형식

- 주소 표현을 위해 오랫동안 Base58을 사용하고 있으나, BIP0173에서 Bech32 표준이 제안되어 일부(Segwit)에서 사용되기 시작하는 추세
- 스크립트 유형(P2PKH, P2SH, P2WPKH 등)에 따라 version 바이트(주소 타입 구분자)와 해싱 대상이 달라지지만, Base58 인코딩 과정 자체는 동일하다.

- Base58 주소 생성 방법 (P2PKH 예시)
  1. version 바이트 선택: 메인넷 `0x00`, 테스트넷 `0x6f` (주소 타입 구분)
  2. 대상 데이터를 hash160 (SHA256 + RIPEMD160)으로 해시하여 20바이트 생성
      - 이렇게 연속으로 2개의 해시함수를 적용하는 방법을 [hash160](https://www.btcschools.net/bitcoin/bitcoin_tool_hash160.php)이라 함
      - P2PKH는 공개키를, P2SH는 redeemScript를 해시함
  3. version 바이트와 20바이트 해시 결과를 합침 (21바이트)
  4. 3의 결과를 hash256으로 해시하고 첫 4바이트를 체크섬으로 추가
  5. 최종 25바이트를 Base58로 부호화

- 비트코인에서 비밀키는 256 비트 숫자, 보통 전파하지 않지만 드물게 종이 지갑에서 소프트웨어 지갑으로 전송하는 경우 WIF(Wallet import format) 형식 사용
  1. 메인넷 비밀키는 `0x80`, 테스트넷 주소는 `0xef`로 시작
  2. 비밀키를 32바이트 길이의 빅 엔디언으로 표현
  3. 공개키를 압축 SEC 형식으로 표현했다는 표식으로 `0x01`를 붙임
  4. 1번을 순서대로 연결
  5. 4의 결과와 체크섬(4에서 얻은 결과를 hash256로 해시하고 그 결과에서 첫 4바이트를 취함)을 합친 후 Base58로 부호화

- <https://en.bitcoin.it/wiki/Wallet_import_format>

### 트랜잭션

- 트랜잭션은 암호화되지 않으며 공개적으로 조회할 수 있다.
- 각 트랜잭션은 이중 SHA-256 해시를 통해 생성된 고유한 트랜잭션 ID(TXID)를 가짐
- 이전 트랜잭션의 출력(UTXO, Unspent Transaction Output)을 입력으로 참조하는 UTXO 모델을 사용한다.

트랜잭션 구성 요소

1. Version: 트랜잭션 형식의 버전 번호
2. Inputs: 4개의 하부 필드를 가지고 있음
    - Previous Tx ID
    - Previous Tx index (출력 번호)
    - ScriptSig (해제 스크립트, [varInt](https://wiki.bitcoinsv.io/index.php/VarInt) 형식)
    - Sequence
3. Outputs: 2개의 하부 필드를 가지고 있음
    - 비트코인 금액
    - ScriptPubKey (잠금 스크립트)
4. Locktime: 트랜잭션의 유효 시점을 규정

**Inputs**

- 하나의 입력은 1개부터 2³² 개의 이전 트랜잭션 출력을 참조할 수 있으며, 모든 입력값은 완전히 할당되어야 하고, 할당되지 않은 사토시는 채굴 수수료로 지불된다.

- 시퀀스 필드는 매우 빈번한 거래를 록타임 필드와 함께 표현하기 위함이었으나, 채굴자들이 악용할 수 있는 구조적 문제로 인해 원래 의도대로 사용되지 못했다.

  - 원래 의도는 같은 입력을 사용하는 여러 버전의 트랜잭션 중 가장 높은 시퀀스 번호를 가진 최신 버전을 채택하는 것이었다.
  - e.g. alice와 bob이 지불 채널을 운영
    - 처음에 alice가 밥에게 1 BTC를 지불하는 트랜잭션(시퀀스 1)을 생성하고
    - 나중에 합의를 변경하여 0.5 BTC만 지불하는 트랜잭션(시퀀스 2)을 생성하는 경우
    - 가장 높은 시퀀스 번호인 2번 트랜잭션이 최종적으로 블록에 포함되어야 한다.

  - 하지만 채굴자는 mempool에 있는 여러 버전의 트랜잭션 중 자신에게 유리한 것을 선택할 수 있는 권한이 있기 때문에, 밥으로부터 뇌물을 받거나 더 높은 수수료를 제공받아 시퀀스 1 트랜잭션(1 BTC 지불)을 의도적으로 채택할 수 있다.
  - 이런 경우 앨리스는 최신 합의인 0.5 BTC가 아닌 1 BTC를 잃게 되므로, 채굴자의 선택에 따라 거래 당사자의 의도와 다른 결과가 발생할 수 있다.

- 따라서 현재는 시퀀스 대신 RBF(Replace-By-Fee)와 `OP_CHECKSEQUENCEVERIFY`로 주로 사용되고 있다.

  - 아주 작은 수수료로 트랜잭션을 보낸 경우 채굴자들은 수수료가 작기 때문에 이 트랜잭션을 블록에 포함시키는 것을 주저할 수 있음. 이 경우 보낸 트랜잭션은 mempool이라고 하는 채굴 컴퓨터의 메모리에 계속해서 머무르게 됨.
  - 본인의 트랜잭션을 빨리 블록에 포함시키고 싶을 때, 같은 입력에서 출력 수수료를 올려 다시 보내는 것을 RBF라 함.
  - 단 대체되는 트랜잭션의 시퀀스 필드는 `0xfeffffff`로 설정되어있어야 한다.

**Outputs**

- 비트코인 단위는 64bit 사토시 단위로 표현한다. (1 BTC = 100,000,000 satoshi)

- UTXO(Unspent transaction output)은 아직 사용하지 않은 트랜잭션 출력으로, 네트워크상의 풀 노드들은 UTXO 집합을 항상 최신 상태로 유지해야한다.
  - UTXO 집합에서 이전 트랜잭션 출력을 확인해보는 것으로 손쉡게 이중 지불을 막을 수 있다.
  - 만약 새 트랜색션의 입력이 UTXO 집합에 없는 이전 트랜잭션의 출력을 가리킨다면 전파하지 않고 버릴 수 있다.
  - 트랜잭션을 검증하기 위해 이전 트랜잭션 출력으로부터 금액과 잠금 스크립트를 자주 확인해야하기 때문에, 집합 내 UTXO 내용을 빠르게 확인할 수 있으면 검증도 빨라진다.

- 채굴자가 트랜잭션을 블록에 포함시킬 동기가 되는 수수료는, 단순이 입력의 합에서 출력의 합을 뺀 값이다.
  - 입력은 금액 필드를 갖고 있지 않기 때문에 이전 트랜잭션의 출력에서 찾아야한다. 만양 풀 노드를 갖고 있지 않다면 믿을 수 있는 제 3자가 제공하는 풀 노드로부터 이 정보를 얻어야한다.

**Locktime**

- 트랜잭션 전파 후 실행을 지연시키는 방법을 제공한다. (e.g. 600,00의 록타임을 가지는 트랜잭션은 600,001 블록까지는 블록체인에 포함될 수 없다.)
- 록타임 값이 500,000,000보다 작으면 블록 높이로, 같거나 크면 유닉스 타임으로 해석한다.
- 입력에 포함된 시퀀스 값이 `ffffffff`면 록타임은 무시된다.
- 록타임의 주요 문제는 록타임에 도달했을 때 트랜잭션의 수신자가 트랜잭션이 유효한지 확신할 수 없다는 점이다. 시가닝 많이 지나 부도 가능성이 있는 은행 수표와 비슷하다.
  - BIP65에서 도입한 `OP_CHECKSEQUENCEVERIFY`는 록타임까지 출력을 사용하지 못하게 해서 이러한 상황을 방지한다.

### 스크립트

- 스크립트는 프로그래밍 언어이다. 연산자와 데이터를 가지고, 스택 기반으로 주어진 명령어가 하나씩 처리된다.
- ScriptPubKey와 ScriptSig 모두 같은 방식으로 파싱된다.
- 파싱을 시작하고 처음 읽은 한 바이트 값이 n이고 이 값이 `0x01`~`0x4b`(1~75) 사이의 값이면 n바이트 길이만큼 이어서 읽은 숫자를 한 원소로 간주한다. 그렇지 않으면 그 바이트 값은 오피 코드를 의미한다. [연산자, 오피코드 대응 표](https://en.bitcoin.it/wiki/Script)
  
- 비트코인의 스크립트에선 반복문을 허용하지 않는다. (튜링 완전하지 않다.)
  - 튜링 완전한 스마트 계약 언어인 Solidity를 이용하는 이더리움은 gas라고 하는 무언가를 프로그램 실행 대가로 지불하도록 강제하여 해결한다.

- 거래를 하기 위해선 이전 트랜잭션의 해제 스크립트(ScriptPubKey)로 코인을 해제 후, 이번 트랜잭션의 잠금 스크립트(ScriptSig)로 잠가야 한다. 따라서 이전 트랜잭션 정보를 가져와야한다.

- 비트코인에서 해제 스크립트는 잠금 스크립트와 분리되어 실행된다. 이는 해제 스크립트가 잠금 스크립트 실행에 영향을 주지 않도록 하기 위해서이다. 결합하여 실행하는 경우, 해제 스크립트에서 잠금하지 않고 return 1하여 종료되는 허점이 생긴다.

**스크립트 예시**

- **P2PK**(Pay to Public Key)
  - 비트코인 초기에 널리 사용됨
  - ECDSA 서명 공개키로 보내고, 비밀키 소유자는 서명을 통해 비트코인을 해제하고 사용할 수 있음.
  - 스크립트
    - ScriptPubKey: `<signature>`
      - ac는 `OP_CEHECKSIG`를 의미함
    - ScriptSig: `<pubkey>ac`
  - 해제/잠금 스크립트를 합쳐 실행하면 `<signature><pubkey>ac`, `OP_CEHECKSIG`가 앞의 2개 원소를 꺼내어 공개키로 서명이 올바른지 확인한다.
  - `OP_CEHECKSIG` 연산자는 서명이 올바르면 스택 위에 1을, 아니면 0을 올린다.
  - 초기 IP to IP 지불이나 채굴 비트코인이 있는 출력에 사용되었다. 하지만 IP to IP 지불 시스템은 MITM 공격에 취약해 점차 사용하지 않게 되었다.
  - 사람간의 거래에선 공개키의 길이가 길어 불편하고, UTXO 집합의 크기를 많이 차지한다는 단점이 있다.

- **P2PKH**(Pay to Public Key Hash)
  - P2PK 스크립트 대비 짧은 주소를 사용하고, hash160으로 추가 보호한다는 장점이 있다.
  - SEC 형식 공개키가 잠금 스크립트가 아닌 해제 스크립트에 있다는 차이가 있다.
    - P2PK는 ScriptPubKey에 공개키가 직접 노출되어 블록체인에 영구적으로 기록되지만, P2PKH는 코인을 사용하는 시점(ScriptSig)까지 공개키가 드러나지 않는다.
    - 양자 컴퓨터의 Shor's algorithm은 공개키로부터 개인키를 계산할 수 있는데, P2PKH에서는 사용하지 않은 UTXO의 경우 공개키가 노출되지 않아 양자 컴퓨터 공격에 대한 시간적 여유를 확보할 수 있다.
    - 공격자가 개인키를 얻으려면 먼저 hash160(SHA256 + RIPEMD160)을 역산하여 공개키를 찾고, 그 다음 ECDSA를 깨서 개인키를 찾아야 하는 이중 보호층이 있다.

  - 스크립트
    - ScriptSig

       ```
       <signature>
       <publickey>
       ```

    - ScriptPubKey

       ```
       OP_DUP
       OP_HASH160
       <publickey hash>
       OP_EQUALVERIFY
       OP_CHECKSIG
       ```

  - 주소 생성
    - Base58 인코딩, version 바이트 `0x00` (메인넷) / `0x6f` (테스트넷)
    - 해싱 대상: 압축 혹은 비압축 SEC 형식 공개키
    - 최종 주소: 메인넷 `1`, 테스트넷 `m` 또는 `n`으로 시작

  - z 계산 및 검증
    - 서명 생성 시 z 계산
      1. 현재 트랜잭션의 모든 입력 ScriptSig를 빈 값으로 교체
      2. 현재 입력의 ScriptSig만 이전 출력의 ScriptPubKey로 교체
         - `OP_DUP OP_HASH160 <pubkey hash> OP_EQUALVERIFY OP_CHECKSIG`
      3. 수정된 트랜잭션을 이중 SHA-256 해시하여 z 생성
    - 검증 시: `OP_CHECKSIG`가 동일한 방식으로 z를 재계산하고 서명 검증

- **P2RPH**(Pay to R-Puzzle Hash)
  - R-Puzzle은 k 값에 대한 지식 증명을 사용하여 코인을 사용할 수 있도록 하는 스크립트이다.
  - k는 비트코인 개인키와 동일한 수학적 집합에서 가져온 값이며, r(k와 생성자 점을 곱한 x 좌표)을 생성하는데 사용된다.
  - 스크립트
    - ScriptSig

      ```
      <sig'> <sig> <pubKey>
      ```

    - ScriptPubKey

      ```
      OP_OVER
      OP_3
      OP_SPLIT
      OP_NIP
      OP_1
      OP_SPLIT
      OP_SWAP
      OP_SPLIT
      OP_DROP
      OP_HASH160
      <rHash>
      OP_EQUALVERIFY
      OP_TUCK
      OP_CHECKSIGVERIFY
      OP_CHECKSIG
      ```

  - 공개키가 스크립트 솔루션의 일부로 검증되지 않기 때문에, 임의의 키 쌍을 사용하여 트랜잭션에 서명할 수 있다.

- **P2MS**(Pay to Multi-Signature)
  - 여러 공개키로 비트코인을 잠그고, 그 중 일부(또는 전부)의 서명을 요구하여 잠금을 해제하는 스크립트이다.
  - m-of-n 표기법을 사용한다. (예: 2-of-3는 3개의 공개키 중 2개의 서명이 필요함)
  - 스크립트 (2-of-3 multisig 예시)
    - ScriptSig

      ```
      OP_0
      <signature1>
      <signature2>
      ```

      - `OP_CHECKMULTISIG`는 많은 서명과 공개키를 가져와 유효한 서명의수가 기준 이상인지 여부는 1, 0으로 반환하는 명령어이다.
        - 스택 원소를 m+n+2개보다 한 개 더 가져오도록 (off-by-one) 잘못 구현되어 있어서 더미 값(`OP_0`)을 넣어줘야 한다. 이 원소가 실제로 계산에 사용되지는 않는다.

    - ScriptPubKey

      ```
      OP_2
      <pubkey1>
      <pubkey2>
      <pubkey3>
      OP_3
      OP_CHECKMULTISIG
      ```

  - 블록체인에서 P2MS를 직접 사용하는 것은 드물며, 대부분 P2SH나 P2WSH로 래핑되어 사용된다.
  - 노드 중계를 위해 최대 3개의 공개키로 제한된다.

- **P2SH**(Pay to Script Hash)
  - P2MS(다중 서명)는 여러 공개키를 ScriptPubKey에 직접 포함해야 하므로 스크립트가 매우 길어진다.
  - P2SH는 복잡한 스크립트를 20바이트 해시로 압축하여 이러한 문제를 해결한다.
  - BIP16에서 도입되었으며, 2012년 4월 1일부터 활성화되었다.
  - 스크립트
    - ScriptSig

      ```
      <signature1>
      <signature2>
      <redeemScript>
      ```

      - 실제 스크립트 로직이 포함된 redeemScript를 제공해야 한다.
      - redeemScript는 송금받을 때 공개되지 않고, 코인을 사용할 때 공개된다.

    - ScriptPubKey

      ```
      OP_HASH160
      <redeemScriptHash>
      OP_EQUAL
      ```

      - redeemScript를 hash160으로 해시한 값만 저장한다.

  - 주소 생성
    - Base58 인코딩, version 바이트 `0x05` (메인넷) / `0xc4` (테스트넷)
    - 해싱 대상: redeemScript
    - 최종 주소: 메인넷 `3`, 테스트넷 `2`로 시작
    - 주소만으로는 내부 스크립트 종류를 알 수 없음 (multisig, P2WPKH 등)

  - 검증 방식
    - ScriptPubKey가 `OP_HASH160 <20바이트 해시> OP_EQUAL` 패턴이면 P2SH로 인식한다.
    - 2단계 검증을 수행한다.
      1. 해시 검증: ScriptSig의 마지막 원소(redeemScript)를 hash160으로 해시하여 ScriptPubKey의 해시값과 일치하는지 확인
      2. 스크립트 실행: 일치하면 redeemScript를 역직렬화하여 나머지 ScriptSig 원소들과 함께 실행
    - 두 단계 모두 통과해야 트랜잭션이 유효하다.

  - z 계산 및 검증
    - 서명 생성 시 z 계산
      1. 현재 트랜잭션의 모든 입력 ScriptSig를 빈 값으로 교체
      2. 현재 입력의 ScriptSig만 redeemScript로 교체
         - 예: 2-of-3 multisig의 경우 `OP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG`
      3. 수정된 트랜잭션을 이중 SHA-256 해시하여 z 생성
    - 검증 시: redeemScript 내부의 `OP_CHECKSIG` (또는 `OP_CHECKMULTISIG`)가 동일한 방식으로 z를 재계산하고 서명 검증

  - redeemScript의 최대 크기는 520바이트로 제한, 스크립트 실행 시 스택 원소는 최대 201개로 제한된다.
  - 반복문을 방지하기 위해 P2SH는 중첩될 수 없다. (P2SH 안에 또 다른 P2SH를 넣을 수 없음)

- 인증키 등을 이용한 표준 스크립트 뿐만 아니라, 덧셈 문제를 푸는 등의 잠금/해제 스크립트를 작성하는 것도 가능하다.
  - 일례로 Peter Todd가 해시 충돌을 찾은 사람이 가져갈 수 있도록 잠근 비트코인이 있다.
  - 구글이 2017년 2월 SHA-1에 대한 해시 충돌을 찾았고, 이외 SHA에 대한 해시 충돌을 찾으면 해제할 수 있는 비트코인도 있다.
  - 참고
    - <https://bitcointalk.org/index.php?topic=293382>
    - <https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html>

### 트랜잭션 검증과 생성

트랜잭션을 수신한 후 모든 노드는 트랜잭션이 네트워크 규칙에 부합되도록 만들어졌는지 확인한다. 아래와 같은 항목을 주로 확인한다.

1. 트랜잭션의 입력이 가리키는 비트코인이 존재하고 사용 가능한가? (이중 지불 방지)

    - 모든 풀 노드는 자신이 관리하고 있는 UTXO 집합을 들여다보는 것으로 비트코인이 존재하고 사용 가능한지 확인할 수 있다. 단순히 트랜잭션 하나를 보는 것으론 알 수 없다.
    - 풀 노드는 이중 지불 여부를 쉽게 확인할 수 있지만 라이트 노드는 이런 정보를 외부에서 가져와야한다.

2. 입력 비트코인의 합이 출력 비트코인의 합보다 크거나 같은가? (코인이 생성되지 않도록 함)

    - 코인을 생성할 수 있는 것은 코인 베이스 트랜잭션 뿐이다. 이외 트랜잭션에선 코인이 생성되면 안된다.
    - 위에서도 언급했듯, 입력에는 명시적인 비트코인 금액 정보가 없으므로 UTXO 집합에서 찾아야한다. 라이트 노드는 풀 노드에게 이 정보를 물어야한다.

3. 입력 해제 스크립트는 참조하는 출력의 잠금 스크립트를 해제하는가?
    - 검증의 수학적 원리
      - z와 r을 검증 공식에 포함시키는 것은 "화살촉에 목표물을 새기는 것"과 같다.
      - z는 메시지 해시(트랜잭션 내용의 요약)이고, r은 서명의 일부이다.
      - `v = r/s` 계산에 r이 포함되므로, 검증 과정이 서명 자체와 수학적으로 결합된다.
      - 서명 생성 시: `r = (kG).x`, `s = (z + re)/k` (e는 개인키, k는 임시 비밀값)
      - 검증 계산:

        ```
        R' = uG + vP
           = (z/s)G + (r/s)P
           = (z/s)G + (r/s)(eG)      // P = eG
           = (1/s)(z + re)G
           = (1/s) · s · kG          // s = (z + re)/k
           = kG
        ```

      - 따라서 `R'.x = (kG).x = r`이므로, 서명자가 정확히 이 메시지(z)를 이 개인키(e)로 서명했음이 증명된다.

    - z에 ScriptPubKey를 포함시키는 이유
      - z는 특정 UTXO의 ScriptPubKey를 포함한 트랜잭션을 해시한 값이다.
      - 서명은 "나는 이 특정 ScriptPubKey를 해제할 권한이 있다"는 증명이다.
      - ScriptPubKey를 z에 포함시켜야 공격자가 서명을 다른 출력에 재사용하는 것을 방지할 수 있다.
      - 계약서에 서명하는 것처럼, 서명할 메시지에 계약 내용(ScriptPubKey)이 포함되어야 "이 서명이 정확히 이 계약에 대한 것"임을 보장한다.

    - 이 과정을 통해 서명자가 개인키를 소유하고 있음을 증명하면서도, 개인키 자체는 노출하지 않는다.

    - e.g. ECDSA 서명 검증 과정

      1. 서명 `(r, s)`, 공개키 `P`, 메시지 해시 `z`를 준비한다.
         - z 생성 과정 (순환 참조 문제 해결)
           - 서명은 ScriptSig에 포함되지만, 서명을 만들 때는 아직 서명이 존재하지 않음
           - 트랜잭션을 다음과 같이 수정하여 서명할 메시지를 생성함
             1. 모든 입력의 ScriptSig를 빈 스크립트로 교체
             2. 현재 서명 중인 입력의 ScriptSig만 해당 입력이 참조하는 이전 출력의 ScriptPubKey로 교체
             3. 수정된 트랜잭션을 이중 SHA-256 해시하여 z 생성
           - 예: 2개 입력이 있는 트랜잭션에서 Input 0 서명 시
             - Input 0: ScriptSig = `<이전 출력 0의 ScriptPubKey>`
             - Input 1: ScriptSig = `(empty)`
           - 각 입력은 자신이 참조하는 UTXO의 ScriptPubKey에 대해서만 서명하므로, 입력들은 독립적으로 서명 가능
         - r과 s는 DER 형식으로 직렬화된 서명에서 파싱한다.
         - P는 SEC 형식으로 직렬화된 공개키를 파싱한다.

      2. `u = z/s mod n`을 계산한다. (n은 secp256k1 곡선의 위수)
      3. `v = r/s mod n`을 계산한다.
      4. `R' = uG + vP`를 계산한다. (G는 생성자점, P는 공개키)
         - 타원곡선 점 덧셈 연산을 수행하여 새로운 점 R'을 얻는다.
      5. `r == R'.x mod n`인지 확인한다.
         - 일치하면 스택에 1을 푸시하고, 일치하지 않으면 0을 푸시한다.
         - `R'`의 x 좌표와 서명의 r 값이 일치하면 서명이 유효하다.

- <https://teachbitcoin.io/presentations/transaction_sighash.html>
- <https://developer.bitcoin.org/devguide/transactions.html>

### 블록

- 비트코인에서 블록은 트랜잭션 순서를 정하는 방법이다. 트랜잭션 순서를 정한다면 같은 비트코인을 사용하려는 트랜잭션 중 첫 번째 것만 유효하고 나머지는 무효로 간주하여 이중 지불을 방지할 수 있다.
- 이를 위해선 네트워크의 모든 노드가 시시각각 발생하는 모든 트랜잭션의 순서에 합의해야한다. 비트코인은 이를 위해 트랜잭션을 10분마다 한 번씩 정산한다.
- 코인 베이스 트랜잭션
  - 코인베이스 트랜잭션은 블록마다 들어가는 첫 번째 트랜잭션이며 비트코인을 발행하는 유일한 트랜잭션이다.
    - 정확히 하나의 입력을 갖고 이전 트랜잭션 해시값으로 32바이트의 0을, 이전 트랜잭션 출력 번호로 `ffffffff`를 갖는 경우 코인베이스 트랜잭션이다.

      ```python
        def is_coinbase(self):
            '''Returns whether this transaction is a coinbase transaction or not'''
            # check that there is exactly 1 input
            if len(self.tx_ins) != 1:
                return False
            # grab the first input
            first_input = self.tx_ins[0]
            # check that first input prev_tx is b'\x00' * 32 bytes
            if first_input.prev_tx != b'\x00' * 32:
                return False
            # check that first input prev_index is 0xffffffff
            if first_input.prev_index != 0xffffffff:
                return False
            return True
      ```

  - 보통 P2PKH 잠금 스크립트로 채굴자가 지정한 주소에 블록 보상으로 주어지는 비트코인과 블록 내 모든 트랜잭션 수수료를 잠가 놓는다.
  - 이러한 방법으로 채굴자의 채굴 활동은 코인베이스 트랜잭션으로 보상된다.
  - 바이트 단위로 똑같은 코인베이스 트랜잭션을 그 트랜잭션 ID 역시 동일하다. 트랜잭션 ID의 중복을 방지하기 위해, Gavin Andresen은 채굴하고 있는 블록의 높이를 코인베이스 해제 스크립트의 첫 원소로 한다는 soft-fork 규정을 [BIP0034](https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki)로 제안했다.
    - 여기서 fork는 비트코인 네트워크를 구선하는 채굴 노드의 소프트웨어를 새 버전으로 업데이트하는 것을 의비한다. 이 때 soft-fork는 예전 버전 노드와 최신 버전 노드가 혼재되어있어도 네트워크가 멈추지 않고 돌아가도록 하는 것, hark-fork는 양립할 수 없는 방식의 소프트웨어 업데이트이다. 하드포크는 주로 업데이트보다는 새로운 블록체인을 분기시키는 경우에 사용된다.
    - 이러한 인위적 포크 외에 일상적인 상황에서 2개 이상의 노드가 거의 동시에 작업 증명을 찾았을 때도 포크가 발생했다고 말한다. 이 경우는 일시적으로 노드들이 가진 블록체인의 마지막 블록이 동기되지 못하는 경우로 시간이 지날수록 우세한 블록이 생기면서 이러한 상황이 해소된다.

#### 블록 해시와 작업증명

- Tx와 마찬가치로 해시 값이 ID로 쓰인다.
- 블록 해시값은 앞에 많은 0 자릿수를 가진다. proof of work을 찾기 위해 이 값이 기준치 이하이도록 하는 조건이 붙기 때문이다.
  - 작업증명을 찾는 것은 특정한 조건을 만족하는 매우 희소한 숫자를 찾는 것이다. 채굴자는 많은 숫자를 발생시켜 특정한 조건을 만족하는지 조사해야한다.
  - sha256 해시 값은 균일하게 분산된 값을 생성하고, 처음 비트가 0으로 시작하는 블록을 생성하기 위한 확률은 매우 낮다.
- 채굴 난이도를 높이기 위해, 비트코인 네트워크에선 블록을 등록하기 위해 이 해시값이 특정 기준치 이하의 값이도록 강제한다.
- 채굴자는 논스 값을 원하는대로 변경하여 블록 헤더의 해시값을 찾는다.

- 난이도
  - 난이도는 서로 다른 난이도간 쉽게 비교하도록 목푯값에 반비례하게 정의된다.

    ```
    difficulty = fxfff * 256^0x1d-2 / target
    ```

  - 비트코인은 평균 10분마다 블록을 생성하도록 설계되었다.
    - 네트워크 해시파워 변화에 대응하여 2016블록(약 2주)마다 난이도를 자동으로 조정한다.
  - 조정 시점: 블록 높이가 2016의 배수일 때 (블록 #2016, #4032, #6048, ...)
  - 난이도 조정 계산식

    ```
    new_target = previews_target × (최근 2016블록 소요 시간 / 20160분)
    ```

    - 20160분 = 2016블록 × 10분 (이상적인 소요 시간)
    - 최근 2016블록 소요 시간 = (마지막 블록 타임스탬프) - (2016블록 전 타임스탬프)
    - 조정 제한: 최대 4배 증가 또는 1/4 감소로 제한됨 (급격한 변화 방지)
      - 실제 소요 시간이 8주(80640분)를 초과하면 8주로 간주
      - 실제 소요 시간이 3.5일(5040분) 미만이면 3.5일로 간주

  - 예시
    - 최근 2016블록이 1주(10080분)에 생성됨 → 너무 빠른 상태
    - 새 목표값 = 현재 목표값 × (10080 / 20160) = 현재 목표값 × 0.5
    - 목표값이 절반으로 줄어들어 난이도가 2배 증가
    - 결과: 다음 2016블록은 다시 2주에 가깝게 생성됨

#### Merkle Tree

- 머클트리(Merkle Tree)는 해시 트리의 일종으로, 블록에 포함된 모든 트랜잭션을 효율적으로 요약하고 검증하기 위한 자료구조이다.
  - [세그먼트 트리](https://blog.rlaisqls.com/til/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8%ED%8A%B8%EB%A6%AC)에서, 합 대신 각 데이터를 연결해 해시한 데이터를 저장하는 버전이다.
- 머클트리를 사용하면 특정 트랜잭션의 블록 포함 여부(proof of inclusion)를 알아내는 데 유용하다. 이렇게 알아내는 과정을 단순 지급 검증이라 부른다(Simplified Payment Verifycation).

- 구조

  1. 노드 생성
      - 트랜잭션 ID(TXID)가 리프 노드의 값이 된다.
      - 블록의 각 트랜잭션을 이중 SHA-256 해시하여 리프 노드를 생성한다.

  2. 부모 노드 계산
      - 인접한 두 개의 노드를 연결(concatenate)하여 이중 SHA-256 해시한다.
      - `parent_hash = SHA-256(SHA-256(left_child + right_child))`
      - 이 과정을 트리의 맨 위(루트)에 도달할 때까지 반복한다.

  3. 홀수 개 노드 처리
      - 각 레벨에서 노드 개수가 홀수인 경우, 마지막 노드를 복제하여 짝을 맞춘다.
      - 예: 트랜잭션이 5개면 5번째 트랜잭션 해시를 복제하여 6개로 만든다.

  4. 루트
      - 트리의 최상위 노드가 머클 루트(Merkle Root)이다.
      - 이 값이 블록 헤더의 `Merkle Root` 필드에 저장된다.
      - 32바이트(256비트) 해시값 하나로 블록 내 모든 트랜잭션을 대표한다.

    ```
           Merkle Root
                |
        +-------+-------+
        |               |
      Hash01          Hash23
        |               |
     +--+--+         +--+--+
     |     |         |     |
    Hash0 Hash1    Hash2 Hash3
     |     |         |     |
    Tx0   Tx1       Tx2   Tx3
    ```

- n개의 트랜잭션이 있을 때, 검증에 필요한 해시값은 log₂(n)개이다. 검증 과정은 다음과 같다.
  1. 검증하려는 트랜잭션의 해시값을 계산한다.
  2. 머클 경로를 따라 형제 노드와 결합하여 상위 노드를 계산한다.
  3. 최종적으로 계산된 루트 해시가 블록 헤더의 머클 루트와 일치하는지 확인한다.

- SPV(Simplified Payment Verification)와 PV(Payment Verification)
  - 풀 노드는 블록에 대한 제한된 정보를 보내고, 라이트노드는 이로부터 머클 루트를 계산해 블록 헤더의 루트와 계산된 루트의 일치 여부를 확인할 수 있다.
  - 라이트 노드의 보안(SPV)은 네트워크에서 정직한 노드의 비율과 작업증명 생성 비용이 높을 수록 증가한다. 반대로, 불손한 노드가 많은 경우 라이트 노드가 완전히 속을 수도 있다.
  - 100 비트코인 이상의 큰 금액을 움직이는 트랜잭션의 경우 풀 노드가 라이트 노드를 속이고자 하는 경제적 인센티브를 가질 수 있다. 따라서 그러한 트랜잭션은 안전하게 풀 노드에서 검증되어야 한다.
  - 풀 노드의 지급 검증과 라이트노드의 단순 지급 검증의 가장 큰 차이는 이중 지불 검증 여부이다.
    - 라이트 노드는 UTXO 데이터베이스가 없고 블록체인의 헤더만 갖고 있어서 UTXO 확인을 통한 이중 지불 검증이 불가능하다.
    - `getutxo` 커맨드로 UTXO를 풀 노드에게 물어볼 순 있지만 그 응답을 일반적으로 신뢰할 수 없다. ([BIP-0064](https://github.com/bitcoin/bips/blob/master/bip-0064.mediawiki))
    - 트랜잭션이 블록 안에 있고 블록이 체인 상에 충분히 깊숙이 들어가 있다면 라이트 노드는 이런 상황이 되기 위해 풀 노드가 검증에 들인 에너지가 크다고 판단하여 이중 지불 없이 확정된 트랜잭션이라고 간주한다. 즉 풀 노드의 검증 노력을 믿는다.

- 단순 지급 검증은 유용하지만 중요한 단점이 있어 대부분의 라이트 노드 지갑에선 단순 지급 검증을 사용하지 않는다. 대신 지갑 업체 자체 서버의 데이터를 활용한다.
  - 단순 지급 검증의 가장 큰 단점은 풀 노드가 라이트 노드의 관심 트랜잭션을 알게 된다느 ㄴ것이다. 즉, 트랜잭션에 들어있는 사용자의 계정 정보가 알려지게 된다.
  - 라이트 노드는 자시닝 관심 있는 트랜잭션을 풀 노드에 알려줄 때 블룸 필터를 사용하여 이러한 트랜잭션 공개 문제를 완화시킬 수 있다.

#### bloom filter

- 라이트 노드가 풀 노드에게 관심 트랜잭션 집합만 알려주는 것이 아니라 이를 포함한 더 많은 트랜잭션이 있는 superset(상위집합)을 알려줌으로써 해결할 수 있다.

- bloom filter는 superset에 포함되는 트랜잭션을 선정하는 필터이다.
  - 예를 들어 50개의 트랜잭션이 있으면, 라이트 노드는 5개씩 10 그룹으로 만들고 그 중 관심 트랜잭션이 포함된 한 그룹을 보낸다. 이러한 트랜잭션의 그루핑은 동일한 입력에 대해서 매번 동일해야한다.
  - 이를 위해 해시 함수와 나머지 함수를 이용한다. (해시 후, `해시결과 mod m` 번째 그룹 선택)
  - 블룸 필터는 다음 항목들을 검사한다:
      1. 트랜잭션 해시 (TXID)
      2. 출력 스크립트의 데이터 요소들
      3. 입력 outpoint (previous tx hash + index)
      4. 입력 스크립트의 데이터 요소들

- 그룹이 작고 많아질 수록, 오탐률이 낮아지고 비트 필드 크기가 커져 전송 용량에 부담을 줄 수 있다. 반대로 그룹이 크고 적어질 수록 오탐률이 높아지고 전송 용량이 작아진다.
  - 원하는 오탐률을 맞추기 위해 그룹 갯수(필터 크기)와 해시 함수 갯수를 조정한다. 해시 함수 갯수를 조정하는 것은, 필터에서 무작위 비트를 1로 설정하는 것과 비슷한 역할을 한다.

- 적절한 오탐률을 맞추기 위해서, 아래 식으로 계산할 수 있다.
  - 필터 크기

    ```
    S = -1 / (ln(2))² × N × ln(P) / 8
    ```

    - `S`: 필터 크기 (바이트)
    - `N`: 필터에 추가할 원소 개수
    - `P`: 원하는 거짓 긍정 확률

  - 해시 함수

    ```
    K = S × 8 / N × ln(2)
    ```

    - `K`: 해시 함수 개수
  - 예시: N=10개 원소, P=0.01 (1% 거짓 긍정률)
    - S ≈ 12바이트
    - K ≈ 7개 해시 함수

- 구조 및 파라미터 ([BIP0037](https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki))
    1. 비트 필드 (`Filter Byte Array`)
        - 최대 크기: 36,000바이트
        - 관심 대상을 표시하는 비트맵
    2. 해시 함수 개수 (`nHashFuncs`)
        - 최대: 50개
        - 여러 해시 함수를 사용하여 거짓 긍정률을 조절한다.
    3. Tweak 파라미터 (`nTweak`)
        - 해시 함수의 시드값
        - 같은 필터라도 다른 tweak 값으로 다른 결과를 생성하여 프라이버시를 향상시킨다.
    4. 업데이트 플래그 (`nFlags`)
        - `BLOOM_UPDATE_NONE`: 필터를 업데이트하지 않음
        - `BLOOM_UPDATE_ALL`: 매칭된 scriptPubKey의 outpoint를 필터에 추가
        - `BLOOM_UPDATE_P2PUBKEY_ONLY`: P2PK나 P2MS 형식일 때만 선택적으로 추가

- 암호학적으로 안전하지 않지만, 출력을 빠르게 계산할 수 있는 Murmur3 해시를 사용한다.
- 해시 함수는 다음 공식으로 생성한다

  ```
  hash(i) = MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, data) mod (filterSize * 8)
  ```

  - `i`: 해시 함수 인덱스 (0 ~ nHashFuncs-1)
  - `0xFBA4C795`: 큰 소수 (해시 함수 다양화)
  - `data`: 검사할 데이터 (트랜잭션 해시, 스크립트 등)

- 라이트 노드가 블룸 필터를 생성하면 이를 풀 노드에게 알려줘야한다. 그러면 풀 노드는 포함증명을 보낼 때 이를 활용한다. 블룸필터에 관련된 command는 아래와 같은 것들이 있다.

    1. `filterload`: 블룸 필터 설정
        - 라이트 노드가 풀 노드에게 필터를 전송한다.
        - 이후 풀 노드는 필터에 매칭되는 트랜잭션과 블록만 전송한다.

    2. `filteradd`: 필터에 원소 추가
        - 기존 필터에 새로운 원소를 동적으로 추가한다.
        - 새 주소를 감시하고 싶을 때 사용한다.

    3. `filterclear`: 필터 제거
        - 현재 설정된 블룸 필터를 제거한다.
        - 이후 풀 노드는 필터링 없이 모든 트랜잭션을 전송한다.

    4. `merkleblock`: 머클 경로와 함께 블록 전송
        - 블록 헤더 + 매칭된 트랜잭션들의 머클 경로를 포함한다.
        - 라이트 노드는 이를 통해 트랜잭션이 블록에 포함되었음을 검증할 수 있다.

#### 블록 헤더 구성

- 블록 헤더는 아래처럼 구성된다.
  - Version
  - Previous block
  - Merkel root
  - Timestamp
  - Bits
  - Nonce

**Version**

- 블록 버전을 나타내는 4바이트 리틀 엔디언 정수이다.
- 블록이 따르는 검증 규칙을 나타내며, 소프트포크 신호용으로도 사용된다.
- 노드는 Version 값으로 블록이 따르는 합의 규칙을 판단한다.
- 알 수 없는 버전의 블록도 대부분 허용하지만, 특정 규칙 위반 시 거부할 수 있다.

- 버전별 지원 규칙
  - Version 1: 초기 비트코인 블록 (2009년)
  - Version 2: BIP34 활성화 - 블록 높이를 코인베이스에 포함 (2012년)
  - Version 3: BIP66 활성화 - strict DER 서명 검증 (2015년)
  - Version 4: BIP65 활성화 - `OP_CHECKLOCKTIMEVERIFY` 추가 (2015년)

- 여러 소프트포크를 동시에 신호할 수 있도록 BIP9 버전 비트 시그널링이 도입되었다.
  - 구조
    - 상위 3비트: `001` 고정 (BIP9 신호임을 표시)
    - 나머지 29비트: 소프트포크 제안 신호용으로 사용
  - 작동 방식
    - 채굴자가 특정 비트를 1로 설정하여 해당 소프트포크 지지를 표명한다.
    - 2016블록(약 2주) 기간 동안 95% 이상 신호 시 소프트포크가 활성화된다.
  - 예시
    - Segwit: 비트 1 사용 (`0x20000002`)
    - Taproot: 비트 2 사용 (`0x20000004`)
    - `0x20000000`: BIP9 형식 기본값 (모든 신호 비트 0)

**Previous block**

- 이전 블록의 해시 값이다.

Merkel root

- 단순 지급 검증(SPV)에서 활용된다.

**Timestamp**

- 유닉스 형식으로 표현된 4바이트 값이다. (2106년까지 사용)
- 크게 두 용도로 사용된다
  - 블록에 포함된 트랜잭션의 록타임이 유닉스 형식 시간으로 표현되었을 때 그 트랜잭션이 활성화되는 시점을 알아내기 위한 비교 기준 ([BIP0113](https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki)에 따라 지난 11 블록의 타임스탬프 중 중앙값과 비교, 많은 수수료를 얻으려고 자신이 생성하는 블록의 타임스탬프를 실제보다 증가시키지 않게 하기 위함)
  - 2016개 블록마다 비트값/목푯값/난이도를 재계산하는 과정

**Bits**

- 목표값(target)을 압축 표현한 4바이트 필드이다.
- bits는 과학적 표기법과 유사하게 목표값을 인코딩한다.
  - 첫 1바이트(exponent): 지수를 나타냄
  - 나머지 3바이트(coefficient): 계수를 나타냄
  - 변환 공식: `target = coefficient × 256^(exponent - 3)`

- 예시: bits가 `0x1d00ffff`인 경우
  - exponent = `0x1d` (29)
  - coefficient = `0x00ffff`
  - target = `0x00ffff × 256^(29-3) = 0x00ffff × 256^26`
  - 이는 약 `0x00ffff0000000000000000000000000000000000000000000000000000000000`

- 이 압축 표현을 통해 256비트 target 값을 32비트로 저장할 수 있다.
- 블록 해시값이 이 target 값보다 작거나 같아야 블록이 유효하다.

**Nonce**

- Number used only ONCE의 줄임말로 작업증명을 위해 채굴자가 변경하는 값이다.

### 네트워크

- 비트코인 네트워크의 모든 노드는 자신이 알고 있는 트랜잭션, 블록, 인접 노드 리스트를 전파하기에 broadcast, gossip 네트워크이다.

- 메시지 구조

    | Field Size | Description | Data type | Comments |
    |------------|-------------|-----------|----------|
    | 4 | magic | `uint32_t` | 메시지의 출처 네트워크를 나타내는 매직 값. 스트림 상태를 알 수 없을 때 다음 메시지를 찾는 데 사용됨 |
    | 12 | command | `char[12]` | 패킷 내용을 식별하는 ASCII 문자열, NULL로 패딩됨 (NULL이 아닌 패딩은 패킷 거부됨) |
    | 4 | length | `uint32_t` | payload의 바이트 단위 길이 |
    | 4 | checksum | `uint32_t` | sha256(sha256(payload))의 첫 4바이트 |
    | ? | payload | `uchar[]` | 실제 데이터 |

- magic: 메인넷은 `f9beb4d9`, 테스트넷은 `0b110907`
- command: 모든 커맨드는 [문서](https://en.bitcoin.it/wiki/Protocol_documentation)에서 볼 수 있다.
- checksum: payload를 이중 SHA-256 해시한 값의 첫 4바이트로, 데이터 무결성을 검증한다.

- 핸드셰이킹

  1. version 메시지 교환
     - 노드 A가 노드 B에 TCP 연결을 시작하고 `version` 메시지를 전송한다.
     - `version` 메시지에는 다음 정보가 포함된다
       - 프로토콜 버전 (e.g. 70015)
       - 노드가 지원하는 서비스 (services 비트필드)
       - 타임스탬프
       - 수신자 주소 (IP:포트)
       - 발신자 주소 (IP:포트)
       - nonce (연결 고유 식별자, 자기 자신에게 연결하는 것을 방지)
       - user agent (노드 소프트웨어 식별, e.g. "/Satoshi:0.21.0/")
       - 최신 블록 높이 (start_height)
       - relay 플래그 (트랜잭션 중계 여부)
     - 노드 B도 자신의 `version` 메시지를 노드 A에게 전송한다.

  2. verack 메시지 교환
     - 각 노드는 상대방의 `version` 메시지를 받으면 `verack` (version acknowledgement) 메시지를 전송한다.
     - `verack` 메시지는 payload가 없는 간단한 확인 메시지이다.
     - 양쪽 노드가 모두 `verack`를 받으면 핸드셰이킹이 완료된다.

  3. 연결 확립
     - 핸드셰이킹이 완료되면 노드들은 트랜잭션, 블록, 인벤토리 등의 메시지를 교환할 수 있다.
     - 이후 `getaddr`, `getdata`, `inv`, `tx`, `block` 등의 커맨드로 네트워크 통신이 진행된다.

### Segwit

- 세그윗은 segregated witness의 약자로 비트코인 네트워크에서 2017년 활성화된 소프트포크이다.
  - 수학에서 witness는 어떤 조건을 만족하는 수의 존재를 증명할 때 그러한 수의 예로 들 수 있는 특정 값을들 말한다. 암호학의 맥락에서 보면 서명이나, 공개키 등을 witness라고 할 수 있다. 왜냐하면 각각 서명 검증 조건식과 공개키 암호 조건식을 만족하는 특정값이기 때문이다.
  - Segregated witness는 이러한 witness에 해당하는 서명이나 공개키를 스크립트에서 분리하여 떼어놓는다(segregation)는 의미이다.

- 트랜잭션 직렬화 형식
  - 일반 트랜잭션: `[Version 4byte][Input count][Inputs]...[Outputs]...[Locktime 4byte]`
  - Segwit 트랜잭션: `[Version 4byte][Marker 0x00][Flag 0x01][Input count][Inputs]...[Outputs]...[Witness]...[Locktime 4byte]`
  - Version(4바이트) 다음의 **5번째 바이트가 marker** `0x00`이고, 6번째 바이트가 flag `0x01`이다.
  - 이 marker와 flag로 노드는 segwit 트랜잭션임을 인식하고 witness 데이터를 파싱한다.
  - marker와 flag는 트랜잭션 해시(TXID) 계산에 포함되지 않는다.

- 세그윗의 효과를 정리하면 다음과 같다
  - 트랜잭션이 작아져 블록 크기가 증가
  - Transaction malleability(가변성) 문제 해결
    - 트랜잭션 의미는 유지하면서 트랜잭션 ID가 변경될 수 있는 성질을 말한다. 라이트닝 네트워크에서 가장 작은 단위인 결제 채널을 만들 때 트랜잭션 ID가 변할 수 있다는 사실은 중요한 고려 사항이다. 트랜잭션 ID가 변할 수 있으면 결제 채널을 안전하게 만드는 것이 어려워진다.
    - 서명을 다시 생성하지 않고 조작 가능한 유일한 필드는 각 입력에 있는 해제 스크립트이기 때문에,
      - 트랜잭션 ID가 변경될 수 있다는 것은 **해제 스크립트가 변경될 수 있다**는 의미이다.
      - 예를 들어, 서명 생성시 얻은 `(r, s)`와 `(r, -s)`가 모두 유효한 서명이기에 가변성 문제가 발생한다. 각 노드에서는 일단 s와 -s 중 N/2보다 작은 것을 취해서 문제를 해결한다. 또한, `OP_CHECKMULTISIG`의 off-by-one 버그도 가변성 문제를 야기한다.
    - 이는 트랜잭션 ID가 고정되지 않은 결제 체널에서 문제가 된다. (블록체인에 들어가면 트랜잭션 ID가 고정되므로 상관없다.)
    - 증인필드는 트랜잭션 해싱에 들어가지 않는 필드이므로, **해제 스크립트가 변경되어도 ID가 변경되지 않게 된다**.
  - Quadratic hashing(이차 해싱) 문제 해결
  - 오프라인 지갑 수수료 계산의 보안 강화

- **P2WPKH**(Pay to Witness Public Key Hash)
  - Segwit의 가장 기본적인 트랜잭션 형식이다.
  - [BIP0141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki)과 [BIP0143](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki)에서 정의되었다.
  - P2PKH의 segwit 버전으로, 서명과 공개키를 witness 필드로 분리한 형태이다.

  - 스크립트
    - ScriptSig

      ```
      (empty)
      ```

      - witness 필드로 분리되어 ScriptSig는 비어있다.

    - ScriptPubKey

      ```
      OP_0
      <20-byte pubkey hash>
      ```

      - `OP_0`은 witness version 0을 의미한다.
      - 20바이트 공개키 해시가 뒤따른다.

    - Witness

      ```
      <signature>
      <pubkey>
      ```

      - 서명과 공개키가 witness 필드에 위치한다.
      - 이 데이터는 트랜잭션 ID 계산에 포함되지 않는다.

  - 주소 생성
    - Bech32 인코딩 사용 ([BIP0173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki))
    - 해싱 대상: 공개키를 hash160 → 20바이트
    - HRP(Human Readable Part): 메인넷 `bc`, 테스트넷 `tb`
    - Witness version 0 + 20바이트 해시를 5비트 그룹으로 변환 후 Bech32 체크섬 추가
    - 최종 주소: `bc1` 또는 `tb1`로 시작 (예: `bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4`)
    - Base58 대비 장점: 대소문자 구분 없음, 오류 검출 우수, QR 코드 효율성 향상

  - z 계산 및 검증
    - 서명 생성 시 z 계산 (BIP0143 서명 해싱)
      - P2PKH와 달리 더 효율적인 해싱 방식을 사용한다.
      - 각 입력마다 모든 이전 출력을 다시 해싱하지 않고, 한 번만 해싱한다.
      - 계산 복잡도가 O(n²)에서 O(n)으로 개선된다.
      - 주요 해시 컴포넌트
        1. `hashPrevouts`: 모든 입력의 outpoint를 이중 SHA-256 해시
        2. `hashSequence`: 모든 입력의 sequence를 이중 SHA-256 해시
        3. `hashOutputs`: 모든 출력을 이중 SHA-256 해시
      - 최종 z는 이러한 컴포넌트들과 현재 입력 정보를 결합하여 생성
    - 검증 시: witness 필드의 서명과 공개키를 사용하여 동일한 방식으로 검증

- **P2SH-P2WPKH**(Pay to Script Hash - Pay to Witness Public Key Hash)
  - P2WPKH를 P2SH로 래핑한 형태이다.
  - Segwit 호환성을 제공하기 위한 전환기적 스크립트 형식이다.
  - 구형 지갑도 P2SH 주소로 segwit 출력에 송금할 수 있게 한다.

  - 스크립트
    - ScriptSig

      ```
      <redeemScript>
      ```

      - redeemScript는 `OP_0 <20-byte pubkey hash>`이다.
      - 실제 서명과 공개키는 witness 필드에 위치한다.

    - ScriptPubKey

      ```
      OP_HASH160
      <20-byte redeemScript hash>
      OP_EQUAL
      ```

      - P2SH 형식과 동일하다.
      - redeemScript를 hash160으로 해시한 값을 저장한다.

    - Witness

      ```
      <signature>
      <pubkey>
      ```

      - P2WPKH와 동일하게 서명과 공개키가 witness 필드에 위치한다.

  - 주소 생성
    - P2SH와 동일한 Base58 인코딩 과정 사용
    - 해싱 대상: redeemScript (`OP_0 <20-byte pubkey hash>`)
    - 최종 주소: 메인넷 `3`, 테스트넷 `2`로 시작 (예: `3J98t1WpEZ73CNmYviecrnyiWrnqRhWNLy`)
    - 외부적으로는 일반 P2SH와 구분 불가능 (코인 사용 시 redeemScript 공개되어야 드러남)

  - 검증 방식
    - 2단계 검증을 수행한다.
      1. P2SH 검증: ScriptSig의 redeemScript를 hash160으로 해시하여 ScriptPubKey의 해시값과 일치하는지 확인
      2. Segwit 검증: redeemScript가 `OP_0 <20-byte hash>` 패턴이면 witness 필드로 P2WPKH 검증 수행
    - 두 단계 모두 통과해야 트랜잭션이 유효하다.

  - z 계산 및 검증
    - 서명 생성 시 z 계산
      - P2WPKH와 동일한 BIP0143 해싱 방식을 사용한다.
      - redeemScript(`OP_0 <20-byte pubkey hash>`)의 공개키 해시를 사용하여 z를 생성한다.
    - 검증 시: witness 필드의 데이터로 동일한 방식으로 z를 재계산하고 서명 검증

  - 장점
    - 하위 호환성: 구형 지갑도 P2SH 주소로 송금 가능
    - Segwit 혜택: 트랜잭션 가변성 해결, 효율적인 해싱, 낮은 수수료

  - 단점
    - P2WPKH보다 약간 큰 트랜잭션 크기 (redeemScript 포함)
    - 네이티브 P2WPKH보다 약간 높은 수수료
    - 2단계 검증으로 인한 추가 연산

  - 사용 시기
    - 초기 Segwit 도입 시기에 널리 사용되었다.
    - 현재는 대부분의 지갑이 Segwit을 지원하므로 네이티브 P2WPKH 사용이 권장된다.
    - 하위 호환성이 중요한 경우에만 사용을 고려한다.

---

관련 테스트 및 탐방 사이트

- <https://cryptolinks.com/>
- testnet faucet에서 테스트넷용 코인을 무료로 얻을 수 있음. faucet 목록 확인
  - <https://faucet-list.com/testnet-faucets/bitcoin>
  - <https://en.bitcoin.it/wiki/Testnet#Faucets>
  - <https://faucet.programmingbitcoin.com>
- 현재 동작중인 풀 노드의 IP 주소와 port 번호 검색: <https://bitnodes.io/nodes/>
- 블록 탐색기
  - <https://blockstream.info/testnet/>
  - <https://live.blockcypher.com/btc-testnet/>

---

참고

- 밑부터 시작하는 비트코인 (Programming Bitcoin by Jimmi Song, O'Reilly)
- <https://github.com/bitcoin/bips/tree/master>
- <https://wiki.bitcoinsv.io/index.php/Bitcoin_Transactions>
- <https://wiki.bitcoinsv.io/index.php/VarInt>
- <https://www.btcschools.net/bitcoin/bitcoin_tool_hash160.php>
- <https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf>
- <https://en.bitcoin.it/wiki/Protocol_documentation>
- <https://en.bitcoin.it/wiki/Wallet_import_format>
- 스크립트 관련
  - <https://learnmeabitcoin.com/technical/script/>
  - <https://learnmeabitcoin.com/technical/script/p2pkh/>
  - <https://en.bitcoin.it/wiki/OP_CHECKMULTISIG>
  - <https://opcodeexplained.com/opcodes/OP_CHECKMULTISIG.html>
