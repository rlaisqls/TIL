
이더리움은 크게 세 가지 종류의 클라이언트 소프트웨어가 각자의 역할을 수행하며 상호작용하는 구조이다.

#### Execution Client

실행 클라이언트는 이더리움의 상태(State)를 관리하고 트랜잭션을 실제로 처리하는 소프트웨어이다.

1. 핵심 임무: 실행과 상태 관리
    - 사용자가 보낸 트랜잭션(거래)을 실제로 실행하고, 스마트 컨트랙트 코드를 처리하는 역할을 전담한다.
    - 이더리움의 현재 상태를 데이터베이스 형태로 꼼꼼하게 유지하고 계속 업데이트한다.
        - 상태'정보란 다음을 포함한다:
          - 모든 계정의 이더(ETH) 잔액
          - 스마트 컨트랙트의 내부 저장 공간(데이터)
          - 각 계정의 트랜잭션 횟수(논스, Nonce)
2. 멤풀(Mempool) 관리
    - 아직 블록에 포함되지 않은 트랜잭션들이 대기하는 공간(멤풀)을 관리한다.
    - 나중에 검증자가 블록을 생성할 때, 이 멤풀에서 트랜잭션 목록을 가져간다.
3. 머지 이후의 역할
    - 지분증명 전환(머지) 이후, 실행 클라이언트는 더 이상 스스로 합의를 결정하거나 블록을 생성하지 않는다.
    - 오직 '합의 계층'(비콘 체인)으로부터 받은 명령에 따라서만 트랜잭션을 실행하고, 그 실행 결과를 보고하는 역할만 수행한다.

#### Beacon Chain Client

비콘 체인 클라이언트는 이더리움 네트워크 전체의 합의(Consensus)를 관장하는 '합의 계층'의 구현체이다.

1. Validator 관리 및 조정
    - 32 ETH를 스테이킹하고 활성화된 수십만 개의 검증자 전체를 추적하고 관리한다.
    - 이 검증자들을 무작위로 '위원회(Committee)'에 배정하여 특정 시점에 임무를 부여한다.
2. 블록 생성 및 합의 과정 (슬롯과 에포크)
    - 슬롯 (Slot / 12초):
        - 매 12초(1 슬롯)마다, 무작위로 한 명의 검증자를 '블록 제안자'로 선택한다.
        - 선택된 제안자는 이 12초 안에 새로운 블록을 만들어 네트워크에 전파(제안)해야 한다.
    - 증명 (Attestation):
        - 블록을 제안하지 않는 다른 검증자들은, 제안된 블록이 유효한지 검사하고 투표(증명)한다.
        - 비콘 체인은 이 증명(투표) 데이터를 수집하고 집계하여 네트워크에 전파한다.
    - 에포크 (Epoch / 32 슬롯):
        - 32개의 슬롯(약 6.4분)을 묶어 '에포크'라는 시간 단위로 관리한다.
3. 네트워크의 '완결성' 보장
    - 이더리움 지분증명의 가장 핵심적인 역할은 '되돌릴 수 없는 블록'을 만드는 것이다.
    - 정당화 (Justified): 2개의 에포크가 지나면 블록은 1차로 '정당화'된다.
    - 완결 (Finalized): 정당화된 블록이 다음 에포크에서 다시 한번 정당화 과정을 거치면, 이는 '완결' 상태가 된다.
    - 완결된 블록은 네트워크에 심각한 공격이 발생하더라도 절대 되돌릴 수 없는 최종 기록으로 확정된다.

#### Validator Client

검증자 클라이언트는 실제 스테이킹된 32 ETH를 대표하여 암호화 서명을 수행하는 '실무용' 프로그램이다.

1. 핵심 임무: 지시 이행 및 서명
    - '합의 계층'(비콘 체인 클라이언트)으로부터 "지금 블록을 제안하세요" 또는 "이 블록에 투표하세요"와 같은 구체적인 지시를 받는다.
    - 지시에 따라 실제 암호화 서명 작업을 수행한다.
    - 검증자의 신원을 증명하는 32 ETH 스테이킹에 대한 '서명 키(Signing Key)'를 가장 안전하게 관리한다.
2. 검증자의 2가지 주요 의무
    1. 블록 제안 (Proposing):
        - 자신이 '블록 제안자'로 선정되면, 즉시 '실행 계층'(실행 클라이언트)에 접속한다.
        - 실행 클라이언트의 멤풀에서 트랜잭션 목록을 받아온다.
        - 이 트랜잭션들을 비콘 블록에 포장(Packaging)하여 자신의 키로 서명한 뒤 네트워크에 전파한다.
    2. 블록 증명 (Attesting):
        - 자신이 제안자가 아닐 때(대부분의 시간), 다른 검증자가 제안한 블록의 유효성을 검사한다.
        - "이 블록은 유효하며, 내가 확인했다"라는 내용의 투표(증명) 데이터에 서명하여 제출한다.
3. 보상 및 처벌 (인센티브 구조)
    - 위의 두 가지 의무를 성실히 수행하면 블록 보상과 트랜잭션 수수료(팁)를 보상으로 받는다.
    - 반대로, 의무를 수행하지 않거나(예: 오프라인 상태) 게으름을 피우면 스테이킹한 ETH를 조금 잃는 가벼운 패널티를 받는다.
    - 만약 이중 서명(하나의 슬롯에 두 개의 블록 제안 등)과 같은 고의적인 부정행위를 하면, 스테이킹한 자산의 상당량을 삭감당하는 심각한 처벌(Slashing)을 받는다.

#### 상호 작용

이 세 요소는 Engine API라는 통신 규격을 통해 통신한다.

```mermaid
flowchart TD
    A[Validator Client<br/><sub>검증자 키로 서명</sub>] --> B[Beacon Chain Client (합의 계층)<br/><sub>PoS 합의 + 네트워크 조정</sub>]
    B -->|Engine API (명령/요청)| C[Execution Client (실행 계층)<br/><sub>트랜잭션 실행 + 상태 관리</sub>]
```

하나의 블록이 생성되는 과정:

1. [Beacon Chain → Validator]: 비콘 체인(B)이 특정 검증자 클라이언트(A)에게 "당신이 이번 슬롯의 블록 제안자다"라고 지시한다.
2. [Validator → Execution]: 검증자 클라이언트(A)는 실행 클라이언트(C)에게 "블록에 담을 유효한 트랜잭션 목록을 달라"고 요청한다.
3. [Execution → Validator]: 실행 클라이언트(C)는 멤풀에서 트랜잭션을 처리하여 유효한 목록을 검증자 클라이언트(A)에게 전달한다.
4. [Validator → Beacon Chain]: 검증자 클라이언트(A)는 이 트랜잭션 목록을 포함한 '비콘 블록'을 자신의 키로 서명하여 비콘 체인(B)에 제출(제안)한다.
5. [Beacon Chain]: 비콘 체인(B)은 이 새 블록을 네트워크의 다른 모든 노드에게 전파하여 '증명(투표)' 과정을 시작시킨다.
