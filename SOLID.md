
# SOLID에 대해 알아보자
## 1. 단일 책임 원칙
### (Single Responsibility Principle, SRP)
 하나의 모듈는 하나의 책임만 가져야 한다. SRP를 적용하면 메소드의 책임 영역이 확실해지기 때문에 한 기능이 수정되었을 때 다른 연쇄작용을 일으키지 않는다. 또, 책임을 적절히 분배함으로써 코드의 가독성이 향상되고 유지보수가 용이해진다.


## 2. 개방 폐쇄 원칙
### (Open-Closed Principle, OCP) 
 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다. 코드를 수정하거나 기능을 추가할 일이 생겨도 기존 구성 요소는 바뀌지 말아야한다. 추상화와 다형성으로 구현할 수 있다. 

## 3. 리스코프 치환의 원칙
### (Liskov Substitutiong Principle, LSP)
 서브 타입은 기반 타입이 약속한 규약을 지켜야한다. 상속은 다형성을 통한 확장성 획득을 목표로 하기 때문에, 부모 객체를 자식 객체로 치환했을 때도 정상적으로 동작해야한다. LSP 원칙은 변화에 열려있는 프로그램을 만들 수 있도록 하는 바탕이다. OCP와도 연관된다.

## 4. 인터페이스 분리 원칙
### (Interface segregation Principle, ISP)
 한 클래스는 자신이 이용하지 않는 메서드에 의존하지 않아야힌다. 어떤 객체가 범위가 넓고 일반적인 인터페이스를 상속받으면 필요없는 메소드를 구현해야한다. 이것은 인터페이스에게 과하게 많은 책임을 지게 하는 일이다. ISP는 클라이언트로부터 발생하는 변경이 다른 클라이언트에 미치는 영향을 최소화하는 것을 목표로 한다.

## 5. 의존관계 역전 원칙
### (Dependency Icersion Principle, DIP)
 어떤 객체는 구체화에 의존하지 말고 추상화에 의존해야한다. 프로그램의 일부 기능이 수정될 때, 구체화에 의존하는 코드는 그 기능이 관여하는 부분을 모두 수정해야하지만 DIP를 지키면 같은 인터페이스를 상속받는 다른 클래스로 얼마든지 바꿔낄 수 있다. 의존성 주입을 적절히 사용하여 실현할 수 있다.

---
 
 ### 기타 개념 정리

---

## 제어의 역전
### (Incersion of Control, IoC)
 기존에는 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행하는 프로그램. 즉, 구현 객체가 프로그램의 제어 흐름을 조정하는 프로그램이 많았다. 하지만 이런 방식은 코드의 재사용성과 유지보수성이 낮다. 하지만 그와 반대로 프로그램에 대한 제어 권한을 외부에서 가지고 있는 것을 제어의 역전(Ioc)이라고 한다. IoC는 객체지향성을 잃지 않고 유지보수성이 높은 코드를 만들 수 있게 해준다.<br>
 (+ 프레임워크는 작성된 코드를 제어하고 대신 실행해주는 역할을 한다. Spring도 이와 같은 프레임워크의 일종이다.)

## 의존성 주입
### (Dependency Injection, DI)
IoC를 구현하기 위한 방법 중 하나이다. 말 그대로 어떤 객체에 스프링 컨테이너가 또 다른 객체와 의존성을 맺어주는 행위를 말한다. 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

## Ioc 컨테이너, DI 컨테이너
객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너라고 한다. 어셈블러, 오브젝트 팩토리 등으로 불리기도 한다.