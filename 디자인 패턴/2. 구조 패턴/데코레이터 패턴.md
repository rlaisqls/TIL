# 데코레이터(Decorator) 패턴

데코레이터 패턴은 주어진 상황 및 용도에 따라 객체에 책임을 덧붙이는 패턴이다. 기본 기능에 추가할 수 있는 기능의 종류가 많은 경우에 각 추가 기능을 Decorator 클래스로 정의 한 후 필요한 Decorator 객체를 합함으로써 추가 기능의 조합을 설계 하는 방식이다. 데코레이터 패턴은 객체의 결합 을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해준다.

---

## 예시 코드

```
public interface CommentService {

    void addComment(String comment);
}
public class DefaultCommentService implements CommentService{

    @Override
    public void addComment(String comment) {
        System.out.println(comment);
    }
}
```

댓글을 추가하는 서비스 인터페이스와 그걸 상속받아 구현한 클래스가 있다. 여기에 댓글을 필터링하는 로직을 데코레이터 패턴을 통해 추가해볼 것이다. 

---

```
@RequiredArgsConstructor
public class CommentDecorator implements CommentService{

    private final CommentService commentService;

    @Override
    public void addComment(String comment) {
        commentService.addComment(comment);
    }

}
```

CommentService를 상속받아 CommentDecorator클래스를 만든다. CommentService를 주입받아서 CommentService의 addComment() 메서드를 호출한다. 이 친구가 이제부터 추가할 Decorator들의 근간이 되어줄 것이다. 

---

```
public class SpamFilteringCommentDecorator extends CommentDecorator{

    public SpamFilteringCommentDecorator(CommentService commentService) {
        super(commentService);
    }

    @Override
    public void addComment(String comment) {
        if(isNotSpam(comment)) super.addComment(comment);
    }

    private boolean isNotSpam(String comment) {
        return !comment.contains("http");
    }

}

public class DateCommentDecorator extends CommentDecorator {

    public DateCommentDecorator(CommentService commentService) {
        super(commentService);
    }

    @Override
    public void addComment(String comment) {
        super.addComment(addDate(comment));
    }

    private String addDate(String comment) {
        return comment + "["+ LocalDateTime.now() +"]";
    }

}

public class TrimmingCommentDecorator extends CommentDecorator{

    public TrimmingCommentDecorator(CommentService commentService) {
        super(commentService);
    }

    @Override
    public void addComment(String comment) {
       super.addComment(trim(comment));
    }

    private String trim(String comment) {
        return comment.replace("...", "");
    }

}
```

addComment() 메서드에 필터링, 날짜 추가 등 기능을 추가(Decorate) 해주는 Decorator들이다. 이제 이걸 DefaultCommentService에 추가해주면 된다.

---

```
public class App {

    private static final boolean enabledSpamFilter = true;
    private static final boolean enabledTrimming = true;
    private static final boolean enabledDate = true;

    public static void main(String[] args) {

        CommentService commentService = new DefaultCommentService();

        if (enabledSpamFilter) commentService = new SpamFilteringCommentDecorator(commentService);
        if (enabledTrimming) commentService = new TrimmingCommentDecorator(commentService);
        if (enabledDate) commentService = new DateCommentDecorator(commentService);

        commentService.addComment("ㅇㄹㄴㅇㄹㄴ");
        commentService.addComment("ㅏㅓㅑㅐ...............");
        commentService.addComment("https");
    }
}
```
바로 이렇게 추가해준다. 이렇게 하면 조건에 따라 동적으로 Decorator 로직을 추가해줄 수 있다. Decorator를 모두 추가한 commentService에서 addComment()를 호출하면 Decorator의 addComment()가 차례대로 실행된 후에 서비스가 실행된다. 근데 이게 왜 될까? 같은 인터페이스를 상속받았으니까 특정 Decorator를 commentService에 대입할 수 있다는건 알겠는데, 그게 어떻게 이렇게 차곡차곡 쌓여서 야무지게 실행될 수 있지? 라는 생각이 들었다. 각 클래스의 addComment() 메서드가 호출될 때 각 메서드명을 출력하여 메서드의 실행 시기를 추척해보니 다음과 같은 결과가 나왔다.

> DateCommentDecorator.addComment<br>
CommentDecorator.addComment<br>
TrimmingCommentDecorator.addComment<br>
CommentDecorator.addComment<br>
SpamFilteringCommentDecorator.addComment<br>
CommentDecorator.addComment<br>
DefaultCommentService.addComment<br>
댓글[2022-08-11T14:45:54.203837300]





이 <a href="https://github.com/rlaisqls/GoF-DesignPatterns/tree/master/src/main/java/com/study/gof/designpattrens/_02_StructuralPatterns/decorator">링크</a>로 가면 코드를 볼 수 있다.