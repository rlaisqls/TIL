처음이자 마지막 정올 경험이었던 2020 중등부 정올 2차 문제를 다시 풀어본다.

## 1. 종이접기

> https://www.acmicpc.net/problem/20187

## 2. 등산 마니아

> https://www.acmicpc.net/problem/20188

```c
#include <iostream>
#include <vector>
using namespace std;

int n;
vector<vector<int>> V;

long long res;
long long f(int x, int b) {
    long long ret = 1;
    for (int i=0;i<V[x].size();i++) {
        if (b != V[x][i]) {
            long long cnt = f(V[x][i], x);
            long long k = n-cnt;
            res += cnt*k + cnt*(cnt-1)/2;
            ret += cnt;
        }
    }
    return ret;
}

int main() {
    cin>>n;
    V.resize(n+1);
    for (int i=0;i<n-1;i++) {
        int a, b;
        cin>>a>>b;
        V[a].push_back(b);
        V[b].push_back(a);
    }
    f(1, 1);
    cout<<res;
}
```

## 3. 버블버블

> https://www.acmicpc.net/problem/20190

i번쨰 인덱스의 숫자를 아무 숫자로 바꿀 수 있을 때 배열을 버블소트로 정렬해 필요한 최소 스왑 횟수를 각각 출력하는 문제이다. 즉, 해당 숫자를 어떤 숫자로 바꿔야 스왑 횟수를 최소화할 수 있을지를 고려해야한다.

버블소트의 스왑 횟수는 inversion (i<j, a[i]>a[j]를 만족하는 쌍의 수)와 같다. 우선 각 요소에 대한 inversion을 upeer_bound로 구한다.

```c
#include <iostream>
#include <cmath>
#include <vector>
#include <algorithm>
#include <string.h>
#define MAX 300001
using namespace std;

long long tree[MAX*4];
long long lazy[MAX*4];
int arr[MAX+1];

int n;
int sum(int i) {
    int ans = 0;
    while (i > 0) {
        ans += tree[i];
        i -= (i & -i);
    }
    return ans;
}


void update(int i, int d) {
    while (i <= n) {
        tree[i] += d;
        i += (i & -i);
    }
}

void lazy_update(int l, int r, int x) {
    if (lazy[x]!=0) {
        tree[x]+=lazy[x];
        if (l!=r) {
            lazy[x*2]+=lazy[x];
            lazy[x*2+1]+=lazy[x];
        }
        lazy[x]=0;
    }
}

void update_tree(int l, int r, int x, int gl, int gr, long d) {
    lazy_update(l, r, x);
    if (r<gl||gr<l) return;
    else if (gl<=l&&r<=gr) {
        lazy[x]+=d;
        lazy_update(l, r, x);
    } else {
        int mid = (l+r)/2;
        update_tree(l, mid, x*2, gl, gr, d);
        update_tree(mid+1, r, x*2+1, gl, gr, d);
        tree[x]=tree[x*2]+tree[x*2+1];
    }
}

void update_range(int x, int l, int r, int gl, int gr, int d) {
    lazy_update(l, r, x);
    if (l>gr||r<gl) return;
    if (l>=gl&&r<=gr) {
        tree[x]+=d;
        if (l!=r) {
            lazy[x*2]+=d;
            lazy[x*2+1]+=d;
        }
        return;
    }
    int mid=(l+r)/2;
    update_range(x*2, l, mid, gl, gr, d);
    update_range(x*2+1, mid+1, r, gl, gr, d);
    tree[x] = min(tree[x*2], tree[x*2+1]);
}

int min_tree(int x, int l, int r, int gl, int gr) {
    lazy_update(l, r, x);
    if (l>gr||r<gl) return 1234567890;
    if (l>=gl&&r<=gr) return tree[x];
    else {
        int mid = (l+r)/2;
        return min(min_tree(x*2, l, mid, gl, gr), min_tree(x*2+1, mid+1, r, gl, gr));
    }
}

int sum_tree(int x, int l, int r, int gl, int gr) {
    lazy_update(l, r, x);
    if (l>gr||r<gl) return 1234567890;
    if (l>=gl&&r<=gr) return tree[x];
    else {
        int mid = (l+r)/2;
        return sum_tree(x*2, l, mid, gl, gr) + sum_tree(x*2+1, mid+1, r, gl, gr);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin>>n;
    vector<int> v;
    for (int i=1;i<=n;i++) {
        cin>>arr[i];
        v.push_back(arr[i]);
    }
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
    for (int i=1;i<=n;i++) {
        arr[i]=lower_bound(v.begin(), v.end(), arr[i])-v.begin()+1;
    }

    int s=0, e=n+1;
    long long bubble=0;
    for (int i=n;i>=1;i--) {
        bubble+=sum(arr[i]-1);
        update(arr[i], 1);
    }
    memset(tree, 0, sizeof(lazy));
    memset(tree, 0, sizeof(tree));

    for (int i=1;i<=n;i++) update_range(1, s, e, arr[i]+1, e, 1);
    for (int i=1;i<=n;i++) {
        update_range(1, s, e, arr[i]+1, e, -1);
        int a = min_tree(1, s, e, arr[i], arr[i]);
        int b = min_tree(1, s, e, s, e);
        cout<<bubble-a+b<<" ";
        update_range(1, s, e, s, arr[i]-1, 1);
    }
}
```

## 소감

'종이접기라도 완벽하게 풀자!'며 작지만 최선의 결실을 내고자 했던 과거의 나를 위로하는 마음가짐으로 나머지 문제들을 풀어보았다. 마침 요즘 세그트리와 스위핑을 공부하고 있어서 후반 문제에 접근할 엄두를 낼 수 있었다. 비록 1솔로 장려상을 받았지만 나에겐 큰 의미가 있는 대회였다. 3년 반이 지난 지금와서 생각해봐도 확실히 쉽지 않은 문제들인 것 같다. 특히 대회에서 시간 제약을 가지고 풀기엔 더 그렇다.

2020 정올 후에 내가 그렇게 높은 위치가 아니라는 걸 알게되었다. 더 넓은 세상을 바라보고 더 달려야겠다는 생각을 했다. 그리고 뭐든지 끝까지 잡고 할 수 있는데까지는 파봐야겠다는 마음가짐을 가지게 되었다. 지금의 나는 그떄의 열정과 마음가짐을 계속 가지고 있다고 할 수 있을까. 나의 최선을 다하고 있을까.

최선을 다한다고 물리적으로 느끼는 것도 좋지만 고등학교 생활을 하면서 많은 것들을 배우고 경험했으니 지금의 나는 쌓여온 시간만큼의 힘을 낼 수 있는 사람이면 좋겠다. 쌓여온 노력으로 더 괜찮은 경험, 괜찮은 결과를 만들 수 있으면 좋겠다. 정올은 돌아오지 않지만 나에겐 해결해야할 많은 문제들이 있으니 앞으로도 화이팅..

